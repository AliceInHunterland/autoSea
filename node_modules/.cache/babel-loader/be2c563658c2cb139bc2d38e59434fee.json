{"ast":null,"code":"var _jsxFileName = \"/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/src/components/ImagePrediction.js\";\nimport FFmpeg from \"./FFmpeg\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst ort = require(\"onnxruntime-web\"); // ======================================================================\n// Global variables\n// ======================================================================\n\n\nconst WIDTH = 250;\nconst DIMS = [1, 3, WIDTH, WIDTH];\nconst MAX_LENGTH = DIMS[0] * DIMS[1] * DIMS[2] * DIMS[3];\nconst MAX_SIGNED_VALUE = 255.0;\n\nconst classes = require(\"./imagenet_classes.json\").data;\n\nlet predictedClass;\nlet isRunning = false; // ======================================================================\n// DOM Elements\n// ======================================================================\n\nconst canvas = document.createElement(\"canvas\"),\n      ctx = canvas.getContext(\"2d\"); // ======================================================================\n// Functions\n// ======================================================================\n\nfunction onLoadImage(fileReader) {\n  var img = document.getElementById(\"input-image\");\n  console.log(img);\n\n  img.onload = () => handleImage(img);\n\n  img.src = fileReader.result;\n}\n\nfunction handleImage(img) {\n  var targetWidth = WIDTH;\n  ctx.drawImage(img, 0, 0);\n  const resizedImageData = processImage(img, targetWidth);\n  const inputTensor = imageDataToTensor(resizedImageData, DIMS);\n  var res = run(inputTensor);\n  return /*#__PURE__*/_jsxDEV(\"img\", {\n    src: \"./src/images/salazar-snake.png\",\n    id: \"canvas-image\",\n    className: \"input-image img-fluid rounded mx-auto d-block\",\n    alt: \"Input image\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 52,\n    columnNumber: 9\n  }, this);\n}\n\nfunction processImage(img, width) {\n  const canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = canvas.width * (img.height / img.width);\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n  document.getElementById(\"canvas-image\").src = canvas.toDataURL();\n  return ctx.getImageData(0, 0, width, width).data;\n}\n\nfunction imageDataToTensor(data, dims) {\n  // 1. filter out alpha\n  // 2. transpose from [224, 224, 3] -> [3, 224, 224]\n  const [R, G, B] = [[], [], []];\n\n  for (let i = 0; i < data.length; i += 4) {\n    R.push(data[i]);\n    G.push(data[i + 1]);\n    B.push(data[i + 2]); // here we skip data[i + 3] because it's the alpha channel\n  }\n\n  const transposedData = R.concat(G).concat(B); // convert to float32\n\n  let i,\n      l = transposedData.length; // length, we need this for the loop\n\n  const float32Data = new Float32Array(MAX_LENGTH); // create the Float32Array for output\n\n  for (i = 0; i < l; i++) {\n    float32Data[i] = transposedData[i] / MAX_SIGNED_VALUE; // convert to float\n  } // return ort.Tensor\n\n\n  const inputTensor = new ort.Tensor(\"float32\", float32Data, dims);\n  return inputTensor;\n}\n\nfunction argMax(arr) {\n  let max = arr[0];\n  let maxIndex = 0;\n\n  for (var i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      maxIndex = i;\n      max = arr[i];\n    }\n  }\n\n  return [max, maxIndex];\n}\n\nasync function run(inputTensor) {\n  try {\n    const session = await ort.InferenceSession.create(\"src/assets/model.onnx\");\n    const feeds = {\n      input: inputTensor\n    }; // feed inputs and run\n\n    const results = await session.run(feeds);\n    const [maxValue, maxIndex] = argMax(results.output.data);\n    console.log(results.output.data); // document.write(results.output.data);\n\n    predictedClass = `${classes[maxIndex]}`;\n    console.log(predictedClass);\n    isRunning = false;\n    return predictedClass;\n  } catch (e) {\n    console.error(e);\n    isRunning = false;\n    return e;\n  }\n}\n\nexport default handleImage;","map":{"version":3,"names":["FFmpeg","ort","require","WIDTH","DIMS","MAX_LENGTH","MAX_SIGNED_VALUE","classes","data","predictedClass","isRunning","canvas","document","createElement","ctx","getContext","onLoadImage","fileReader","img","getElementById","console","log","onload","handleImage","src","result","targetWidth","drawImage","resizedImageData","processImage","inputTensor","imageDataToTensor","res","run","width","height","toDataURL","getImageData","dims","R","G","B","i","length","push","transposedData","concat","l","float32Data","Float32Array","Tensor","argMax","arr","max","maxIndex","session","InferenceSession","create","feeds","input","results","maxValue","output","e","error"],"sources":["/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/src/components/ImagePrediction.js"],"sourcesContent":["import FFmpeg from \"./FFmpeg\";\n\nconst ort = require(\"onnxruntime-web\");\n\n\n// ======================================================================\n// Global variables\n// ======================================================================\n\nconst WIDTH = 250;\nconst DIMS = [1, 3, WIDTH, WIDTH];\nconst MAX_LENGTH = DIMS[0] * DIMS[1] * DIMS[2] * DIMS[3];\nconst MAX_SIGNED_VALUE = 255.0;\nconst classes = require(\"./imagenet_classes.json\").data;\n\n\nlet predictedClass;\nlet isRunning = false;\n\n\n\n// ======================================================================\n// DOM Elements\n// ======================================================================\n\n\n\nconst canvas = document.createElement(\"canvas\"),\n    ctx = canvas.getContext(\"2d\");\n\n\n// ======================================================================\n// Functions\n// ======================================================================\n\n\nfunction onLoadImage(fileReader) {\n\n    var img = document.getElementById(\"input-image\");\n    console.log(img);\n    img.onload = () => handleImage(img);\n    img.src = fileReader.result;\n}\n\nfunction handleImage(img) {\n    var targetWidth =  WIDTH;\n    ctx.drawImage(img, 0, 0);\n    const resizedImageData = processImage(img, targetWidth);\n    const inputTensor = imageDataToTensor(resizedImageData, DIMS);\n    var res = run(inputTensor);\n    return(\n        <img src=\"./src/images/salazar-snake.png\" id=\"canvas-image\"\n             className=\"input-image img-fluid rounded mx-auto d-block\" alt=\"Input image\"></img>\n    );\n}\n\nfunction processImage(img, width) {\n    const canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n\n    canvas.width = width;\n    canvas.height = canvas.width * (img.height / img.width);\n    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n    document.getElementById(\"canvas-image\").src = canvas.toDataURL();\n    return ctx.getImageData(0, 0, width, width).data;\n}\n\nfunction imageDataToTensor(data, dims) {\n    // 1. filter out alpha\n    // 2. transpose from [224, 224, 3] -> [3, 224, 224]\n    const [R, G, B] = [[], [], []];\n    for (let i = 0; i < data.length; i += 4) {\n        R.push(data[i]);\n        G.push(data[i + 1]);\n        B.push(data[i + 2]);\n        // here we skip data[i + 3] because it's the alpha channel\n    }\n    const transposedData = R.concat(G).concat(B);\n\n    // convert to float32\n    let i,\n        l = transposedData.length; // length, we need this for the loop\n    const float32Data = new Float32Array(MAX_LENGTH); // create the Float32Array for output\n    for (i = 0; i < l; i++) {\n        float32Data[i] = transposedData[i] / MAX_SIGNED_VALUE; // convert to float\n    }\n\n    // return ort.Tensor\n    const inputTensor = new ort.Tensor(\"float32\", float32Data, dims);\n    return inputTensor;\n}\n\nfunction argMax(arr) {\n    let max = arr[0];\n    let maxIndex = 0;\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] > max) {\n            maxIndex = i;\n            max = arr[i];\n        }\n    }\n    return [max, maxIndex];\n}\n\n\n\n\n\n\n\nasync function run(inputTensor) {\n    try {\n        const session = await ort.InferenceSession.create(\"src/assets/model.onnx\");\n        const feeds = { input: inputTensor };\n\n        // feed inputs and run\n        const results = await session.run(feeds);\n\n        const [maxValue, maxIndex] = argMax(results.output.data);\n        console.log(results.output.data);\n        // document.write(results.output.data);\n        predictedClass = `${classes[maxIndex]}`;\n        console.log(predictedClass)\n        isRunning = false;\n        return(predictedClass);\n    } catch (e) {\n        console.error(e);\n        isRunning = false;\n        return(e);\n    }\n}\nexport default handleImage;"],"mappings":"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"},"metadata":{},"sourceType":"module"}