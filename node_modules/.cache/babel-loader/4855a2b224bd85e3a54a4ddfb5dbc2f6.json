{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = composite;\n\nvar _utils = require(\"@jimp/utils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar compositeModes = _interopRequireWildcard(require(\"./composite-modes\"));\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nfunction composite(src, x, y) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var cb = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return _utils.throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return _utils.throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  var _options = options,\n      mode = _options.mode,\n      opacitySource = _options.opacitySource,\n      opacityDest = _options.opacityDest;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (typeof opacitySource !== 'number' || opacitySource < 0 || opacitySource > 1) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  var blendmode = compositeModes[mode]; // round input\n\n  x = Math.round(x);\n  y = Math.round(y);\n  var baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function (sx, sy, idx) {\n    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    var blended = blendmode({\n      r: this.bitmap.data[idx + 0] / 255,\n      g: this.bitmap.data[idx + 1] / 255,\n      b: this.bitmap.data[idx + 2] / 255,\n      a: this.bitmap.data[idx + 3] / 255\n    }, {\n      r: baseImage.bitmap.data[dstIdx + 0] / 255,\n      g: baseImage.bitmap.data[dstIdx + 1] / 255,\n      b: baseImage.bitmap.data[dstIdx + 2] / 255,\n      a: baseImage.bitmap.data[dstIdx + 3] / 255\n    }, opacitySource);\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);\n  });\n\n  if ((0, _utils.isNodePattern)(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}","map":{"version":3,"sources":["../../src/composite/index.js"],"names":["options","cb","src","throwError","mode","opacitySource","opacityDest","constants","blendmode","compositeModes","x","Math","y","baseImage","dstIdx","blended","r","idx","g","b","a"],"mappings":";;;;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,SAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AAEA,IAAA,cAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,mBAAA,CAAA,CAAA;AAEA;;;;;;;;;;;AASe,SAAA,SAAA,CAAA,GAAA,EAAA,CAAA,EAAA,CAAA,EAAgD;EAAA,IAAlBA,OAAkB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAR,EAAQ;EAAA,IAAJC,EAAI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;;EAC7D,IAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;IACjCA,EAAE,GAAFA,OAAAA;IACAD,OAAO,GAAPA,EAAAA;EACD;;EAED,IAAI,EAAEE,GAAG,YAAY,KAArB,WAAI,CAAJ,EAAwC;IACtC,OAAOC,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,iCAAAA,EAAP,EAAOA,CAAP;EACD;;EAED,IAAI,OAAA,CAAA,KAAA,QAAA,IAAyB,OAAA,CAAA,KAA7B,QAAA,EAAoD;IAClD,OAAOA,MAAAA,CAAAA,UAAAA,CAAAA,IAAAA,CAAAA,IAAAA,EAAAA,yBAAAA,EAAP,EAAOA,CAAP;EACD;;EAZ4D,IAAA,QAAA,GAAA,OAAA;EAAA,IAcvDC,IAduD,GAAA,QAAA,CAAA,IAAA;EAAA,IAcjDC,aAdiD,GAAA,QAAA,CAAA,aAAA;EAAA,IAclCC,WAdkC,GAAA,QAAA,CAAA,WAAA;;EAgB7D,IAAI,CAAJ,IAAA,EAAW;IACTF,IAAI,GAAGG,SAAS,CAAhBH,iBAAAA;EACD;;EAED,IACE,OAAA,aAAA,KAAA,QAAA,IACAC,aAAa,GADb,CAAA,IAEAA,aAAa,GAHf,CAAA,EAIE;IACAA,aAAa,GAAbA,GAAAA;EACD;;EAED,IAAI,OAAA,WAAA,KAAA,QAAA,IAAmCC,WAAW,GAA9C,CAAA,IAAsDA,WAAW,GAArE,CAAA,EAA2E;IACzEA,WAAW,GAAXA,GAAAA;EACD;;EAED,IAAME,SAAS,GAAGC,cAAc,CAhC6B,IAgC7B,CAAhC,CAhC6D,CAkC7D;;EACAC,CAAC,GAAGC,IAAI,CAAJA,KAAAA,CAAJD,CAAIC,CAAJD;EACAE,CAAC,GAAGD,IAAI,CAAJA,KAAAA,CAAJC,CAAID,CAAJC;EAEA,IAAMC,SAAS,GAAf,IAAA;;EAEA,IAAIP,WAAW,KAAf,GAAA,EAAyB;IACvBO,SAAS,CAATA,OAAAA,CAAAA,WAAAA;EACD;;EAEDX,GAAG,CAAHA,SAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAoBA,GAAG,CAAHA,MAAAA,CAApBA,KAAAA,EAAsCA,GAAG,CAAHA,MAAAA,CAAtCA,MAAAA,EAAyD,UAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAIvD;IACA,IAAMY,MAAM,GAAGD,SAAS,CAATA,aAAAA,CAAwBH,CAAC,GAAzBG,EAAAA,EAAgCD,CAAC,GAAjCC,EAAAA,EAAwCN,SAAS,CAAhE,SAAeM,CAAf;IACA,IAAME,OAAO,GAAGP,SAAS,CACvB;MACEQ,CAAC,EAAE,KAAA,MAAA,CAAA,IAAA,CAAiBC,GAAG,GAApB,CAAA,IADL,GAAA;MAEEC,CAAC,EAAE,KAAA,MAAA,CAAA,IAAA,CAAiBD,GAAG,GAApB,CAAA,IAFL,GAAA;MAGEE,CAAC,EAAE,KAAA,MAAA,CAAA,IAAA,CAAiBF,GAAG,GAApB,CAAA,IAHL,GAAA;MAIEG,CAAC,EAAE,KAAA,MAAA,CAAA,IAAA,CAAiBH,GAAG,GAApB,CAAA,IAA4B;IAJjC,CADuB,EAOvB;MACED,CAAC,EAAEH,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IADL,GAAA;MAEEK,CAAC,EAAEL,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAFL,GAAA;MAGEM,CAAC,EAAEN,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAHL,GAAA;MAIEO,CAAC,EAAEP,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAAoC;IAJzC,CAPuB,EAAzB,aAAyB,CAAzB;IAgBAA,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAAoC,KAAA,WAAA,CAAA,QAAA,CAClCE,OAAO,CAAPA,CAAAA,GADFF,GAAoC,CAApCA;IAGAA,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAAoC,KAAA,WAAA,CAAA,QAAA,CAClCE,OAAO,CAAPA,CAAAA,GADFF,GAAoC,CAApCA;IAGAA,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAAoC,KAAA,WAAA,CAAA,QAAA,CAClCE,OAAO,CAAPA,CAAAA,GADFF,GAAoC,CAApCA;IAGAA,SAAS,CAATA,MAAAA,CAAAA,IAAAA,CAAsBC,MAAM,GAA5BD,CAAAA,IAAoC,KAAA,WAAA,CAAA,QAAA,CAClCE,OAAO,CAAPA,CAAAA,GADFF,GAAoC,CAApCA;EA/BFX,CAAAA;;EAoCA,IAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;IACrBD,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;EACD;;EAED,OAAA,IAAA;AACD","sourcesContent":["import { isNodePattern, throwError } from '@jimp/utils';\nimport * as constants from '../constants';\n\nimport * as compositeModes from './composite-modes';\n\n/**\n * Composites a source image over to this image respecting alpha channels\n * @param {Jimp} src the source Jimp instance\n * @param {number} x the x position to blit the image\n * @param {number} y the y position to blit the image\n * @param {object} options determine what mode to use\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default function composite(src, x, y, options = {}, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  if (!(src instanceof this.constructor)) {\n    return throwError.call(this, 'The source must be a Jimp image', cb);\n  }\n\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  let { mode, opacitySource, opacityDest } = options;\n\n  if (!mode) {\n    mode = constants.BLEND_SOURCE_OVER;\n  }\n\n  if (\n    typeof opacitySource !== 'number' ||\n    opacitySource < 0 ||\n    opacitySource > 1\n  ) {\n    opacitySource = 1.0;\n  }\n\n  if (typeof opacityDest !== 'number' || opacityDest < 0 || opacityDest > 1) {\n    opacityDest = 1.0;\n  }\n\n  const blendmode = compositeModes[mode];\n\n  // round input\n  x = Math.round(x);\n  y = Math.round(y);\n\n  const baseImage = this;\n\n  if (opacityDest !== 1.0) {\n    baseImage.opacity(opacityDest);\n  }\n\n  src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(\n    sx,\n    sy,\n    idx\n  ) {\n    const dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);\n    const blended = blendmode(\n      {\n        r: this.bitmap.data[idx + 0] / 255,\n        g: this.bitmap.data[idx + 1] / 255,\n        b: this.bitmap.data[idx + 2] / 255,\n        a: this.bitmap.data[idx + 3] / 255\n      },\n      {\n        r: baseImage.bitmap.data[dstIdx + 0] / 255,\n        g: baseImage.bitmap.data[dstIdx + 1] / 255,\n        b: baseImage.bitmap.data[dstIdx + 2] / 255,\n        a: baseImage.bitmap.data[dstIdx + 3] / 255\n      },\n      opacitySource\n    );\n\n    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(\n      blended.r * 255\n    );\n    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(\n      blended.g * 255\n    );\n    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(\n      blended.b * 255\n    );\n    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(\n      blended.a * 255\n    );\n  });\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n}\n"]},"metadata":{},"sourceType":"script"}