{"ast":null,"code":"import { InferenceSession, Tensor } from \"onnxruntime-web\";\nimport * as Jimp from \"jimp\";\nimport { useState } from \"react\";\n\nconst ort = require(\"onnxruntime-web\"); // ======================================================================\n// Global variables\n// ======================================================================\n\n\nconst WIDTH = 250;\nconst DIMS = [1, 3, WIDTH, WIDTH];\nconst MAX_LENGTH = DIMS[0] * DIMS[1] * DIMS[2] * DIMS[3];\nconst MAX_SIGNED_VALUE = 255.0;\n\nconst classes = require(\"./imagenet_classes.json\").data;\n\nlet predictedClass;\nlet isRunning = false; // ======================================================================\n// DOM Elements\n// ======================================================================\n\nconst canvas = document.createElement(\"canvas\"),\n      ctx = canvas.getContext(\"2d\"); // ======================================================================\n// Functions\n// ======================================================================\n\nfunction onLoadImage(fileReader) {\n  var img = document.getElementById(\"input-image\");\n  console.log(img);\n\n  img.onload = () => handleImage(img);\n\n  img.src = fileReader.result;\n}\n\nasync function handleImage(img, session) {\n  const canvasImg = document.createElement('img');\n  canvasImg.setAttribute(\"id\", \"canvas-image\");\n  const inputImg = document.createElement('img');\n  inputImg.setAttribute(\"id\", \"input-image\");\n  var targetWidth = WIDTH;\n  ctx.drawImage(img, 0, 0);\n  const resizedImageData = processImage(img, targetWidth);\n  const inputTensor = imageDataToTensor(resizedImageData, DIMS);\n  var res = run(inputTensor, session);\n  console.log(res);\n  return res;\n}\n\nfunction processImage(img, width) {\n  const canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n  canvas.width = width;\n  canvas.height = canvas.width * (img.height / img.width);\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height); // document.getElementById(\"canvas-image\").src = canvas.toDataURL();\n\n  return ctx.getImageData(0, 0, width, width).data;\n}\n\nfunction imageDataToTensor(data, dims) {\n  // 1. filter out alpha\n  // 2. transpose from [224, 224, 3] -> [3, 224, 224]\n  const [R, G, B] = [[], [], []];\n\n  for (let i = 0; i < data.length; i += 4) {\n    R.push(data[i]);\n    G.push(data[i + 1]);\n    B.push(data[i + 2]); // here we skip data[i + 3] because it's the alpha channel\n  }\n\n  const transposedData = R.concat(G).concat(B); // convert to float32\n\n  let i,\n      l = transposedData.length; // length, we need this for the loop\n\n  const float32Data = new Float32Array(MAX_LENGTH); // create the Float32Array for output\n\n  for (i = 0; i < l; i++) {\n    float32Data[i] = transposedData[i] / MAX_SIGNED_VALUE; // convert to float\n  } // return ort.Tensor\n\n\n  const inputTensor = new ort.Tensor(\"float32\", float32Data, dims);\n  return inputTensor;\n}\n\nfunction argMax(arr) {\n  let max = arr[0];\n  let maxIndex = 0;\n\n  for (var i = 1; i < arr.length; i++) {\n    if (arr[i] > max) {\n      maxIndex = i;\n      max = arr[i];\n    }\n  }\n\n  return [max, maxIndex];\n}\n\nasync function run(inputTensor, session) {\n  try {\n    // const modelFile = `./static/js/my_classification.onnx`;\n    // console.log(\"loading onnx model\");\n    // console.log(modelFile);\n    //\n    //\n    // const session = await InferenceSession.create(modelFile,{executionProviders: ['wasm']});\n    //\n    // const dataA = new Float32Array(187500);\n    // const tensorA = new Tensor('float32', dataA, [1,3, 250, 250]);\n    const feeds = {\n      input: inputTensor\n    }; // feed inputs and run\n\n    const results = await session.run(feeds);\n    console.log(results);\n    const [maxValue, maxIndex] = argMax(results.output.data);\n    console.log(results.output.data); // document.write(results.output.data);\n\n    predictedClass = `${classes[maxIndex]}`;\n    console.log(predictedClass);\n    isRunning = false;\n    return predictedClass;\n  } catch (e) {\n    console.error(e);\n    isRunning = false;\n    return e;\n  }\n} // export default onLoadImage;\n\n\nexport default handleImage;","map":{"version":3,"names":["InferenceSession","Tensor","Jimp","useState","ort","require","WIDTH","DIMS","MAX_LENGTH","MAX_SIGNED_VALUE","classes","data","predictedClass","isRunning","canvas","document","createElement","ctx","getContext","onLoadImage","fileReader","img","getElementById","console","log","onload","handleImage","src","result","session","canvasImg","setAttribute","inputImg","targetWidth","drawImage","resizedImageData","processImage","inputTensor","imageDataToTensor","res","run","width","height","getImageData","dims","R","G","B","i","length","push","transposedData","concat","l","float32Data","Float32Array","argMax","arr","max","maxIndex","feeds","input","results","maxValue","output","e","error"],"sources":["/Users/ekaterinapavlova/PycharmProjects/onix/autoSea/src/components/ImagePrediction.js"],"sourcesContent":["import {InferenceSession, Tensor} from \"onnxruntime-web\";\nimport * as Jimp from \"jimp\";\nimport {useState} from \"react\";\n\n\nconst ort = require(\"onnxruntime-web\");\n\n\n// ======================================================================\n// Global variables\n// ======================================================================\n\nconst WIDTH = 250;\nconst DIMS = [1, 3, WIDTH, WIDTH];\nconst MAX_LENGTH = DIMS[0] * DIMS[1] * DIMS[2] * DIMS[3];\nconst MAX_SIGNED_VALUE = 255.0;\nconst classes = require(\"./imagenet_classes.json\").data;\n\n\nlet predictedClass;\nlet isRunning = false;\n\n\n\n// ======================================================================\n// DOM Elements\n// ======================================================================\n\n\n\n\nconst canvas = document.createElement(\"canvas\"),\n    ctx = canvas.getContext(\"2d\");\n\n// ======================================================================\n// Functions\n// ======================================================================\n\n\nfunction onLoadImage(fileReader) {\n\n    var img = document.getElementById(\"input-image\");\n    console.log(img);\n    img.onload = () => handleImage(img);\n    img.src = fileReader.result;\n}\n\nasync function handleImage(img,session) {\n    const canvasImg = document.createElement('img');\n    canvasImg.setAttribute(\"id\", \"canvas-image\");\n\n    const inputImg = document.createElement('img');\n    inputImg.setAttribute(\"id\", \"input-image\");\n\n    var targetWidth =  WIDTH;\n    ctx.drawImage(img, 0, 0);\n    const resizedImageData = processImage(img, targetWidth);\n    const inputTensor = imageDataToTensor(resizedImageData, DIMS);\n    var res = run(inputTensor,session);\n    console.log(res);\n    return(res);\n\n}\n\nfunction processImage(img, width) {\n    const canvas = document.createElement(\"canvas\"),\n        ctx = canvas.getContext(\"2d\");\n\n    canvas.width = width;\n    canvas.height = canvas.width * (img.height / img.width);\n    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n\n    // document.getElementById(\"canvas-image\").src = canvas.toDataURL();\n    return ctx.getImageData(0, 0, width, width).data;\n}\n\nfunction imageDataToTensor(data, dims) {\n    // 1. filter out alpha\n    // 2. transpose from [224, 224, 3] -> [3, 224, 224]\n    const [R, G, B] = [[], [], []];\n    for (let i = 0; i < data.length; i += 4) {\n        R.push(data[i]);\n        G.push(data[i + 1]);\n        B.push(data[i + 2]);\n        // here we skip data[i + 3] because it's the alpha channel\n    }\n    const transposedData = R.concat(G).concat(B);\n\n    // convert to float32\n    let i,\n        l = transposedData.length; // length, we need this for the loop\n    const float32Data = new Float32Array(MAX_LENGTH); // create the Float32Array for output\n    for (i = 0; i < l; i++) {\n        float32Data[i] = transposedData[i] / MAX_SIGNED_VALUE; // convert to float\n    }\n\n    // return ort.Tensor\n    const inputTensor = new ort.Tensor(\"float32\", float32Data, dims);\n    return inputTensor;\n}\n\nfunction argMax(arr) {\n    let max = arr[0];\n    let maxIndex = 0;\n    for (var i = 1; i < arr.length; i++) {\n        if (arr[i] > max) {\n            maxIndex = i;\n            max = arr[i];\n        }\n    }\n    return [max, maxIndex];\n}\n\n\n\n\n\n\n\nasync function run(inputTensor,session) {\n    try {\n\n        // const modelFile = `./static/js/my_classification.onnx`;\n        // console.log(\"loading onnx model\");\n        // console.log(modelFile);\n        //\n        //\n        // const session = await InferenceSession.create(modelFile,{executionProviders: ['wasm']});\n        //\n\n        // const dataA = new Float32Array(187500);\n        // const tensorA = new Tensor('float32', dataA, [1,3, 250, 250]);\n\n\n\n        const feeds = { input: inputTensor };\n\n        // feed inputs and run\n\n            const results = await session.run(feeds);\n            console.log(results)\n\n\n\n        const [maxValue, maxIndex] = argMax(results.output.data);\n        console.log(results.output.data);\n        // document.write(results.output.data);\n        predictedClass = `${classes[maxIndex]}`;\n        console.log(predictedClass)\n        isRunning = false;\n        return(predictedClass);\n    } catch (e) {\n        console.error(e);\n        isRunning = false;\n        return(e);\n    }\n}\n// export default onLoadImage;\n\n\nexport default handleImage;"],"mappings":"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"},"metadata":{},"sourceType":"module"}