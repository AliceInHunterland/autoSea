{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { resolveBackend } from './backend-impl';\nimport { Tensor } from './tensor';\nexport class InferenceSession {\n  constructor(handler) {\n    this.handler = handler;\n  }\n\n  async run(feeds, arg1, arg2) {\n    const fetches = {};\n    let options = {}; // check inputs\n\n    if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n      throw new TypeError('\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n    }\n\n    let isFetchesEmpty = true; // determine which override is being used\n\n    if (typeof arg1 === 'object') {\n      if (arg1 === null) {\n        throw new TypeError('Unexpected argument[1]: cannot be null.');\n      }\n\n      if (arg1 instanceof Tensor) {\n        throw new TypeError('\\'fetches\\' cannot be a Tensor');\n      }\n\n      if (Array.isArray(arg1)) {\n        if (arg1.length === 0) {\n          throw new TypeError('\\'fetches\\' cannot be an empty array.');\n        }\n\n        isFetchesEmpty = false; // output names\n\n        for (const name of arg1) {\n          if (typeof name !== 'string') {\n            throw new TypeError('\\'fetches\\' must be a string array or an object.');\n          }\n\n          if (this.outputNames.indexOf(name) === -1) {\n            throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n          }\n\n          fetches[name] = null;\n        }\n\n        if (typeof arg2 === 'object' && arg2 !== null) {\n          options = arg2;\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'options\\' must be an object.');\n        }\n      } else {\n        // decide whether arg1 is fetches or options\n        // if any output name is present and its value is valid OnnxValue, we consider it fetches\n        let isFetches = false;\n        const arg1Keys = Object.getOwnPropertyNames(arg1);\n\n        for (const name of this.outputNames) {\n          if (arg1Keys.indexOf(name) !== -1) {\n            const v = arg1[name];\n\n            if (v === null || v instanceof Tensor) {\n              isFetches = true;\n              isFetchesEmpty = false;\n              fetches[name] = v;\n            }\n          }\n        }\n\n        if (isFetches) {\n          if (typeof arg2 === 'object' && arg2 !== null) {\n            options = arg2;\n          } else if (typeof arg2 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else {\n          options = arg1;\n        }\n      }\n    } else if (typeof arg1 !== 'undefined') {\n      throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n    } // check if all inputs are in feed\n\n\n    for (const name of this.inputNames) {\n      if (typeof feeds[name] === 'undefined') {\n        throw new Error(`input '${name}' is missing in 'feeds'.`);\n      }\n    } // if no fetches is specified, we use the full output names list\n\n\n    if (isFetchesEmpty) {\n      for (const name of this.outputNames) {\n        fetches[name] = null;\n      }\n    } // feeds, fetches and options are prepared\n\n\n    const results = await this.handler.run(feeds, fetches, options);\n    const returnValue = {};\n\n    for (const key in results) {\n      if (Object.hasOwnProperty.call(results, key)) {\n        returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\n      }\n    }\n\n    return returnValue;\n  }\n\n  static async create(arg0, arg1, arg2, arg3) {\n    // either load from a file or buffer\n    let filePathOrUint8Array;\n    let options = {};\n\n    if (typeof arg0 === 'string') {\n      filePathOrUint8Array = arg0;\n\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (arg0 instanceof Uint8Array) {\n      filePathOrUint8Array = arg0;\n\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n    } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {\n      const buffer = arg0;\n      let byteOffset = 0;\n      let byteLength = arg0.byteLength;\n\n      if (typeof arg1 === 'object' && arg1 !== null) {\n        options = arg1;\n      } else if (typeof arg1 === 'number') {\n        byteOffset = arg1;\n\n        if (!Number.isSafeInteger(byteOffset)) {\n          throw new RangeError('\\'byteOffset\\' must be an integer.');\n        }\n\n        if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n          throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n        }\n\n        byteLength = arg0.byteLength - byteOffset;\n\n        if (typeof arg2 === 'number') {\n          byteLength = arg2;\n\n          if (!Number.isSafeInteger(byteLength)) {\n            throw new RangeError('\\'byteLength\\' must be an integer.');\n          }\n\n          if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n            throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n          }\n\n          if (typeof arg3 === 'object' && arg3 !== null) {\n            options = arg3;\n          } else if (typeof arg3 !== 'undefined') {\n            throw new TypeError('\\'options\\' must be an object.');\n          }\n        } else if (typeof arg2 !== 'undefined') {\n          throw new TypeError('\\'byteLength\\' must be a number.');\n        }\n      } else if (typeof arg1 !== 'undefined') {\n        throw new TypeError('\\'options\\' must be an object.');\n      }\n\n      filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n    } else {\n      throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n    } // get backend hints\n\n\n    const eps = options.executionProviders || [];\n    const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n    const backend = await resolveBackend(backendHints);\n    const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n    return new InferenceSession(handler);\n  }\n\n  startProfiling() {\n    this.handler.startProfiling();\n  }\n\n  endProfiling() {\n    this.handler.endProfiling();\n  }\n\n  get inputNames() {\n    return this.handler.inputNames;\n  }\n\n  get outputNames() {\n    return this.handler.outputNames;\n  }\n\n}","map":{"version":3,"sources":["../../lib/inference-session-impl.ts"],"names":[],"mappings":"AAAA;AACA;AAGA,SAAQ,cAAR,QAA6B,gBAA7B;AAGA,SAAQ,MAAR,QAAqB,UAArB;AAQA,OAAM,MAAO,gBAAP,CAAuB;EAC3B,WAAA,CAAoB,OAApB,EAA2C;IACzC,KAAK,OAAL,GAAe,OAAf;EACD;;EAGQ,MAAH,GAAG,CAAC,KAAD,EAAmB,IAAnB,EAAkD,IAAlD,EAAmE;IAC1E,MAAM,OAAO,GAAqC,EAAlD;IACA,IAAI,OAAO,GAAe,EAA1B,CAF0E,CAG1E;;IACA,IAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,KAAK,KAAK,IAAvC,IAA+C,KAAK,YAAY,MAAhE,IAA0E,KAAK,CAAC,OAAN,CAAc,KAAd,CAA9E,EAAoG;MAClG,MAAM,IAAI,SAAJ,CACF,iGADE,CAAN;IAED;;IAED,IAAI,cAAc,GAAG,IAArB,CAT0E,CAU1E;;IACA,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;MAC5B,IAAI,IAAI,KAAK,IAAb,EAAmB;QACjB,MAAM,IAAI,SAAJ,CAAc,yCAAd,CAAN;MACD;;MACD,IAAI,IAAI,YAAY,MAApB,EAA4B;QAC1B,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;MACD;;MAED,IAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;QACvB,IAAI,IAAI,CAAC,MAAL,KAAgB,CAApB,EAAuB;UACrB,MAAM,IAAI,SAAJ,CAAc,uCAAd,CAAN;QACD;;QACD,cAAc,GAAG,KAAjB,CAJuB,CAKvB;;QACA,KAAK,MAAM,IAAX,IAAmB,IAAnB,EAAyB;UACvB,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;YAC5B,MAAM,IAAI,SAAJ,CAAc,kDAAd,CAAN;UACD;;UACD,IAAI,KAAK,WAAL,CAAiB,OAAjB,CAAyB,IAAzB,MAAmC,CAAC,CAAxC,EAA2C;YACzC,MAAM,IAAI,UAAJ,CAAe,2CAA2C,IAAI,GAA9D,CAAN;UACD;;UACD,OAAO,CAAC,IAAD,CAAP,GAAgB,IAAhB;QACD;;QAED,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,IAAzC,EAA+C;UAC7C,OAAO,GAAG,IAAV;QACD,CAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;UACtC,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;QACD;MACF,CArBD,MAqBO;QACL;QACA;QACA,IAAI,SAAS,GAAG,KAAhB;QACA,MAAM,QAAQ,GAAG,MAAM,CAAC,mBAAP,CAA2B,IAA3B,CAAjB;;QACA,KAAK,MAAM,IAAX,IAAmB,KAAK,WAAxB,EAAqC;UACnC,IAAI,QAAQ,CAAC,OAAT,CAAiB,IAAjB,MAA2B,CAAC,CAAhC,EAAmC;YACjC,MAAM,CAAC,GAAI,IAA2D,CAAC,IAAD,CAAtE;;YACA,IAAI,CAAC,KAAK,IAAN,IAAc,CAAC,YAAY,MAA/B,EAAuC;cACrC,SAAS,GAAG,IAAZ;cACA,cAAc,GAAG,KAAjB;cACA,OAAO,CAAC,IAAD,CAAP,GAAgB,CAAhB;YACD;UACF;QACF;;QAED,IAAI,SAAJ,EAAe;UACb,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,IAAzC,EAA+C;YAC7C,OAAO,GAAG,IAAV;UACD,CAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;YACtC,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;UACD;QACF,CAND,MAMO;UACL,OAAO,GAAG,IAAV;QACD;MACF;IACF,CAvDD,MAuDO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;MACtC,MAAM,IAAI,SAAJ,CAAc,6DAAd,CAAN;IACD,CApEyE,CAsE1E;;;IACA,KAAK,MAAM,IAAX,IAAmB,KAAK,UAAxB,EAAoC;MAClC,IAAI,OAAO,KAAK,CAAC,IAAD,CAAZ,KAAuB,WAA3B,EAAwC;QACtC,MAAM,IAAI,KAAJ,CAAU,UAAU,IAAI,0BAAxB,CAAN;MACD;IACF,CA3EyE,CA6E1E;;;IACA,IAAI,cAAJ,EAAoB;MAClB,KAAK,MAAM,IAAX,IAAmB,KAAK,WAAxB,EAAqC;QACnC,OAAO,CAAC,IAAD,CAAP,GAAgB,IAAhB;MACD;IACF,CAlFyE,CAoF1E;;;IAEA,MAAM,OAAO,GAAG,MAAM,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,EAAwB,OAAxB,EAAiC,OAAjC,CAAtB;IACA,MAAM,WAAW,GAAgC,EAAjD;;IACA,KAAK,MAAM,GAAX,IAAkB,OAAlB,EAA2B;MACzB,IAAI,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAA2B,OAA3B,EAAoC,GAApC,CAAJ,EAA8C;QAC5C,WAAW,CAAC,GAAD,CAAX,GAAmB,IAAI,MAAJ,CAAW,OAAO,CAAC,GAAD,CAAP,CAAa,IAAxB,EAA8B,OAAO,CAAC,GAAD,CAAP,CAAa,IAA3C,EAAiD,OAAO,CAAC,GAAD,CAAP,CAAa,IAA9D,CAAnB;MACD;IACF;;IACD,OAAO,WAAP;EACD;;EAOkB,aAAN,MAAM,CACf,IADe,EAC0B,IAD1B,EACwD,IADxD,EAEf,IAFe,EAEM;IACvB;IACA,IAAI,oBAAJ;IACA,IAAI,OAAO,GAAmB,EAA9B;;IAEA,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;MAC5B,oBAAoB,GAAG,IAAvB;;MACA,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,IAAzC,EAA+C;QAC7C,OAAO,GAAG,IAAV;MACD,CAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;QACtC,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;MACD;IACF,CAPD,MAOO,IAAI,IAAI,YAAY,UAApB,EAAgC;MACrC,oBAAoB,GAAG,IAAvB;;MACA,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,IAAzC,EAA+C;QAC7C,OAAO,GAAG,IAAV;MACD,CAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;QACtC,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;MACD;IACF,CAPM,MAOA,IACH,IAAI,YAAY,WAAhB,IACC,OAAO,iBAAP,KAA6B,WAA7B,IAA4C,IAAI,YAAY,iBAF1D,EAE8E;MACnF,MAAM,MAAM,GAAG,IAAf;MACA,IAAI,UAAU,GAAG,CAAjB;MACA,IAAI,UAAU,GAAG,IAAI,CAAC,UAAtB;;MACA,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,IAAzC,EAA+C;QAC7C,OAAO,GAAG,IAAV;MACD,CAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;QACnC,UAAU,GAAG,IAAb;;QACA,IAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,UAArB,CAAL,EAAuC;UACrC,MAAM,IAAI,UAAJ,CAAe,oCAAf,CAAN;QACD;;QACD,IAAI,UAAU,GAAG,CAAb,IAAkB,UAAU,IAAI,MAAM,CAAC,UAA3C,EAAuD;UACrD,MAAM,IAAI,UAAJ,CAAe,oCAAoC,MAAM,CAAC,UAAU,IAApE,CAAN;QACD;;QACD,UAAU,GAAG,IAAI,CAAC,UAAL,GAAkB,UAA/B;;QACA,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;UAC5B,UAAU,GAAG,IAAb;;UACA,IAAI,CAAC,MAAM,CAAC,aAAP,CAAqB,UAArB,CAAL,EAAuC;YACrC,MAAM,IAAI,UAAJ,CAAe,oCAAf,CAAN;UACD;;UACD,IAAI,UAAU,IAAI,CAAd,IAAmB,UAAU,GAAG,UAAb,GAA0B,MAAM,CAAC,UAAxD,EAAoE;YAClE,MAAM,IAAI,UAAJ,CAAe,oCAAoC,MAAM,CAAC,UAAP,GAAoB,UAAU,IAAjF,CAAN;UACD;;UACD,IAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,KAAK,IAAzC,EAA+C;YAC7C,OAAO,GAAG,IAAV;UACD,CAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;YACtC,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;UACD;QACF,CAbD,MAaO,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;UACtC,MAAM,IAAI,SAAJ,CAAc,kCAAd,CAAN;QACD;MACF,CAzBM,MAyBA,IAAI,OAAO,IAAP,KAAgB,WAApB,EAAiC;QACtC,MAAM,IAAI,SAAJ,CAAc,gCAAd,CAAN;MACD;;MACD,oBAAoB,GAAG,IAAI,UAAJ,CAAe,MAAf,EAAuB,UAAvB,EAAmC,UAAnC,CAAvB;IACD,CArCM,MAqCA;MACL,MAAM,IAAI,SAAJ,CAAc,yDAAd,CAAN;IACD,CA1DsB,CA4DvB;;;IACA,MAAM,GAAG,GAAG,OAAO,CAAC,kBAAR,IAA8B,EAA1C;IACA,MAAM,YAAY,GAAG,GAAG,CAAC,GAAJ,CAAQ,CAAC,IAAI,OAAO,CAAP,KAAa,QAAb,GAAwB,CAAxB,GAA4B,CAAC,CAAC,IAA3C,CAArB;IACA,MAAM,OAAO,GAAG,MAAM,cAAc,CAAC,YAAD,CAApC;IACA,MAAM,OAAO,GAAG,MAAM,OAAO,CAAC,oBAAR,CAA6B,oBAA7B,EAAmD,OAAnD,CAAtB;IACA,OAAO,IAAI,gBAAJ,CAAqB,OAArB,CAAP;EACD;;EAED,cAAc,GAAA;IACZ,KAAK,OAAL,CAAa,cAAb;EACD;;EACD,YAAY,GAAA;IACV,KAAK,OAAL,CAAa,YAAb;EACD;;EAEa,IAAV,UAAU,GAAA;IACZ,OAAO,KAAK,OAAL,CAAa,UAApB;EACD;;EACc,IAAX,WAAW,GAAA;IACb,OAAO,KAAK,OAAL,CAAa,WAApB;EACD;;AA7L0B","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nimport { resolveBackend } from './backend-impl';\nimport { Tensor } from './tensor';\nexport class InferenceSession {\n    constructor(handler) {\n        this.handler = handler;\n    }\n    async run(feeds, arg1, arg2) {\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== 'object' || feeds === null || feeds instanceof Tensor || Array.isArray(feeds)) {\n            throw new TypeError('\\'feeds\\' must be an object that use input names as keys and OnnxValue as corresponding values.');\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === 'object') {\n            if (arg1 === null) {\n                throw new TypeError('Unexpected argument[1]: cannot be null.');\n            }\n            if (arg1 instanceof Tensor) {\n                throw new TypeError('\\'fetches\\' cannot be a Tensor');\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError('\\'fetches\\' cannot be an empty array.');\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1) {\n                    if (typeof name !== 'string') {\n                        throw new TypeError('\\'fetches\\' must be a string array or an object.');\n                    }\n                    if (this.outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === 'object' && arg2 !== null) {\n                    options = arg2;\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError('\\'options\\' must be an object.');\n                }\n            }\n            else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of this.outputNames) {\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === 'object' && arg2 !== null) {\n                        options = arg2;\n                    }\n                    else if (typeof arg2 !== 'undefined') {\n                        throw new TypeError('\\'options\\' must be an object.');\n                    }\n                }\n                else {\n                    options = arg1;\n                }\n            }\n        }\n        else if (typeof arg1 !== 'undefined') {\n            throw new TypeError('Unexpected argument[1]: must be \\'fetches\\' or \\'options\\'.');\n        }\n        // check if all inputs are in feed\n        for (const name of this.inputNames) {\n            if (typeof feeds[name] === 'undefined') {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of this.outputNames) {\n                fetches[name] = null;\n            }\n        }\n        // feeds, fetches and options are prepared\n        const results = await this.handler.run(feeds, fetches, options);\n        const returnValue = {};\n        for (const key in results) {\n            if (Object.hasOwnProperty.call(results, key)) {\n                returnValue[key] = new Tensor(results[key].type, results[key].data, results[key].dims);\n            }\n        }\n        return returnValue;\n    }\n    static async create(arg0, arg1, arg2, arg3) {\n        // either load from a file or buffer\n        let filePathOrUint8Array;\n        let options = {};\n        if (typeof arg0 === 'string') {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n        }\n        else if (arg0 instanceof Uint8Array) {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n        }\n        else if (arg0 instanceof ArrayBuffer ||\n            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n            const buffer = arg0;\n            let byteOffset = 0;\n            let byteLength = arg0.byteLength;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 === 'number') {\n                byteOffset = arg1;\n                if (!Number.isSafeInteger(byteOffset)) {\n                    throw new RangeError('\\'byteOffset\\' must be an integer.');\n                }\n                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n                }\n                byteLength = arg0.byteLength - byteOffset;\n                if (typeof arg2 === 'number') {\n                    byteLength = arg2;\n                    if (!Number.isSafeInteger(byteLength)) {\n                        throw new RangeError('\\'byteLength\\' must be an integer.');\n                    }\n                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n                    }\n                    if (typeof arg3 === 'object' && arg3 !== null) {\n                        options = arg3;\n                    }\n                    else if (typeof arg3 !== 'undefined') {\n                        throw new TypeError('\\'options\\' must be an object.');\n                    }\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError('\\'byteLength\\' must be a number.');\n                }\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError('\\'options\\' must be an object.');\n            }\n            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n        }\n        else {\n            throw new TypeError('Unexpected argument[0]: must be \\'path\\' or \\'buffer\\'.');\n        }\n        // get backend hints\n        const eps = options.executionProviders || [];\n        const backendHints = eps.map(i => typeof i === 'string' ? i : i.name);\n        const backend = await resolveBackend(backendHints);\n        const handler = await backend.createSessionHandler(filePathOrUint8Array, options);\n        return new InferenceSession(handler);\n    }\n    startProfiling() {\n        this.handler.startProfiling();\n    }\n    endProfiling() {\n        this.handler.endProfiling();\n    }\n    get inputNames() {\n        return this.handler.inputNames;\n    }\n    get outputNames() {\n        return this.handler.outputNames;\n    }\n}\n//# sourceMappingURL=inference-session-impl.js.map"]},"metadata":{},"sourceType":"module"}