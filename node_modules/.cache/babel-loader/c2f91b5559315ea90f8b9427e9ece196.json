{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function'; // a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\n\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([['float32', Float32Array], ['uint8', Uint8Array], ['int8', Int8Array], ['uint16', Uint16Array], ['int16', Int16Array], ['int32', Int32Array], ['bool', Uint8Array], ['float64', Float64Array], ['uint32', Uint32Array]]); // a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\n\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([[Float32Array, 'float32'], [Uint8Array, 'uint8'], [Int8Array, 'int8'], [Uint16Array, 'uint16'], [Int16Array, 'int16'], [Int32Array, 'int32'], [Float64Array, 'float64'], [Uint32Array, 'uint32']]);\n\nif (isBigInt64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n}\n\nif (isBigUint64ArrayAvailable) {\n  NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n  NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n}\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\n\n\nconst calculateSize = dims => {\n  let size = 1;\n\n  for (let i = 0; i < dims.length; i++) {\n    const dim = dims[i];\n\n    if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n      throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n    }\n\n    if (dim < 0) {\n      throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n    }\n\n    size *= dim;\n  }\n\n  return size;\n};\n\nexport class Tensor {\n  constructor(arg0, arg1, arg2) {\n    let type;\n    let data;\n    let dims; // check whether arg0 is type or data\n\n    if (typeof arg0 === 'string') {\n      //\n      // Override: constructor(type, data, ...)\n      //\n      type = arg0;\n      dims = arg2;\n\n      if (arg0 === 'string') {\n        // string tensor\n        if (!Array.isArray(arg1)) {\n          throw new TypeError('A string tensor\\'s data must be a string array.');\n        } // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n        // error will be populated at inference\n\n\n        data = arg1;\n      } else {\n        // numeric tensor\n        const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n\n        if (typedArrayConstructor === undefined) {\n          throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n        }\n\n        if (Array.isArray(arg1)) {\n          // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n          // incorrect results.\n          // 'typedArrayConstructor' should be one of the typed array prototype objects.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          data = typedArrayConstructor.from(arg1);\n        } else if (arg1 instanceof typedArrayConstructor) {\n          data = arg1;\n        } else {\n          throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n        }\n      }\n    } else {\n      //\n      // Override: constructor(data, ...)\n      //\n      dims = arg1;\n\n      if (Array.isArray(arg0)) {\n        // only boolean[] and string[] is supported\n        if (arg0.length === 0) {\n          throw new TypeError('Tensor type cannot be inferred from an empty array.');\n        }\n\n        const firstElementType = typeof arg0[0];\n\n        if (firstElementType === 'string') {\n          type = 'string';\n          data = arg0;\n        } else if (firstElementType === 'boolean') {\n          type = 'bool'; // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n          // wrong type. We use 'as any' to make it happy.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n          data = Uint8Array.from(arg0);\n        } else {\n          throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n        }\n      } else {\n        // get tensor type from TypedArray\n        const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n\n        if (mappedType === undefined) {\n          throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n        }\n\n        type = mappedType;\n        data = arg0;\n      }\n    } // type and data is processed, now processing dims\n\n\n    if (dims === undefined) {\n      // assume 1-D tensor if dims omitted\n      dims = [data.length];\n    } else if (!Array.isArray(dims)) {\n      throw new TypeError('A tensor\\'s dims must be a number array');\n    } // perform check\n\n\n    const size = calculateSize(dims);\n\n    if (size !== data.length) {\n      throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n    }\n\n    this.dims = dims;\n    this.type = type;\n    this.data = data;\n    this.size = size;\n  } //#endregion\n  //#region tensor utilities\n\n\n  reshape(dims) {\n    return new Tensor(this.type, this.data, dims);\n  }\n\n}","map":{"version":3,"sources":["../../lib/tensor-impl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && typeof BigInt64Array.from === 'function';\nconst isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && typeof BigUint64Array.from === 'function';\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([\n    ['float32', Float32Array],\n    ['uint8', Uint8Array],\n    ['int8', Int8Array],\n    ['uint16', Uint16Array],\n    ['int16', Int16Array],\n    ['int32', Int32Array],\n    ['bool', Uint8Array],\n    ['float64', Float64Array],\n    ['uint32', Uint32Array],\n]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([\n    [Float32Array, 'float32'],\n    [Uint8Array, 'uint8'],\n    [Int8Array, 'int8'],\n    [Uint16Array, 'uint16'],\n    [Int16Array, 'int16'],\n    [Int32Array, 'int32'],\n    [Float64Array, 'float64'],\n    [Uint32Array, 'uint32'],\n]);\nif (isBigInt64ArrayAvailable) {\n    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n}\nif (isBigUint64ArrayAvailable) {\n    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n}\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = (dims) => {\n    let size = 1;\n    for (let i = 0; i < dims.length; i++) {\n        const dim = dims[i];\n        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n        }\n        if (dim < 0) {\n            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n        }\n        size *= dim;\n    }\n    return size;\n};\nexport class Tensor {\n    constructor(arg0, arg1, arg2) {\n        let type;\n        let data;\n        let dims;\n        // check whether arg0 is type or data\n        if (typeof arg0 === 'string') {\n            //\n            // Override: constructor(type, data, ...)\n            //\n            type = arg0;\n            dims = arg2;\n            if (arg0 === 'string') {\n                // string tensor\n                if (!Array.isArray(arg1)) {\n                    throw new TypeError('A string tensor\\'s data must be a string array.');\n                }\n                // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n                // error will be populated at inference\n                data = arg1;\n            }\n            else {\n                // numeric tensor\n                const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n                if (typedArrayConstructor === undefined) {\n                    throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n                }\n                if (Array.isArray(arg1)) {\n                    // use 'as any' here because TypeScript's check on type of 'SupportedTypedArrayConstructors.from()' produces\n                    // incorrect results.\n                    // 'typedArrayConstructor' should be one of the typed array prototype objects.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = typedArrayConstructor.from(arg1);\n                }\n                else if (arg1 instanceof typedArrayConstructor) {\n                    data = arg1;\n                }\n                else {\n                    throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n                }\n            }\n        }\n        else {\n            //\n            // Override: constructor(data, ...)\n            //\n            dims = arg1;\n            if (Array.isArray(arg0)) {\n                // only boolean[] and string[] is supported\n                if (arg0.length === 0) {\n                    throw new TypeError('Tensor type cannot be inferred from an empty array.');\n                }\n                const firstElementType = typeof arg0[0];\n                if (firstElementType === 'string') {\n                    type = 'string';\n                    data = arg0;\n                }\n                else if (firstElementType === 'boolean') {\n                    type = 'bool';\n                    // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n                    // wrong type. We use 'as any' to make it happy.\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    data = Uint8Array.from(arg0);\n                }\n                else {\n                    throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n                }\n            }\n            else {\n                // get tensor type from TypedArray\n                const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n                if (mappedType === undefined) {\n                    throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n                }\n                type = mappedType;\n                data = arg0;\n            }\n        }\n        // type and data is processed, now processing dims\n        if (dims === undefined) {\n            // assume 1-D tensor if dims omitted\n            dims = [data.length];\n        }\n        else if (!Array.isArray(dims)) {\n            throw new TypeError('A tensor\\'s dims must be a number array');\n        }\n        // perform check\n        const size = calculateSize(dims);\n        if (size !== data.length) {\n            throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);\n        }\n        this.dims = dims;\n        this.type = type;\n        this.data = data;\n        this.size = size;\n    }\n    //#endregion\n    //#region tensor utilities\n    reshape(dims) {\n        return new Tensor(this.type, this.data, dims);\n    }\n}\n//# sourceMappingURL=tensor-impl.js.map"]},"metadata":{},"sourceType":"module"}