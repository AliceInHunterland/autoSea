{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Creates a circle out of an image.\n * @param {object} options (optional) r: radius of effect\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    fisheye: function fisheye() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        r: 2.5\n      };\n      var cb = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        cb = options;\n        options = {\n          r: 2.5\n        };\n      }\n\n      var source = this.cloneQuiet();\n      var _source$bitmap = source.bitmap,\n          width = _source$bitmap.width,\n          height = _source$bitmap.height;\n      source.scanQuiet(0, 0, width, height, function (x, y) {\n        var hx = x / width;\n        var hy = y / height;\n        var r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));\n        var rn = 2 * Math.pow(r, options.r);\n        var cosA = (hx - 0.5) / r;\n        var sinA = (hy - 0.5) / r;\n        var newX = Math.round((rn * cosA + 0.5) * width);\n        var newY = Math.round((rn * sinA + 0.5) * height);\n        var color = source.getPixelColor(newX, newY);\n\n        _this.setPixelColor(color, x, y);\n      });\n      /* Set center pixel color, otherwise it will be transparent */\n\n      this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["fisheye","options","r","cb","source","width","height","hx","x","hy","y","Math","rn","cosA","sinA","newX","newY","color"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;;;;;;eAMe,SAAA,QAAA,GAAA;EAAA,OAAO;IACpBA,OADoB,EAAA,SAAA,OAAA,GACc;MAAA,IAAA,KAAA,GAAA,IAAA;;MAAA,IAA1BC,OAA0B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAhB;QAAEC,CAAC,EAAE;MAAL,CAAgB;MAAA,IAAJC,EAAI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;;MAChC,IAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;QACjCA,EAAE,GAAFA,OAAAA;QACAF,OAAO,GAAG;UAAEC,CAAC,EAAE;QAAL,CAAVD;MACD;;MAED,IAAMG,MAAM,GAAG,KAAf,UAAe,EAAf;MANgC,IAAA,cAAA,GAONA,MAAM,CAPA,MAAA;MAAA,IAOxBC,KAPwB,GAAA,cAAA,CAAA,KAAA;MAAA,IAOjBC,MAPiB,GAAA,cAAA,CAAA,MAAA;MAShCF,MAAM,CAANA,SAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAsC,UAAA,CAAA,EAAA,CAAA,EAAU;QAC9C,IAAMG,EAAE,GAAGC,CAAC,GAAZ,KAAA;QACA,IAAMC,EAAE,GAAGC,CAAC,GAAZ,MAAA;QACA,IAAMR,CAAC,GAAGS,IAAI,CAAJA,IAAAA,CAAUA,IAAI,CAAJA,GAAAA,CAASJ,EAAE,GAAXI,GAAAA,EAAAA,CAAAA,IAAwBA,IAAI,CAAJA,GAAAA,CAASF,EAAE,GAAXE,GAAAA,EAA5C,CAA4CA,CAAlCA,CAAV;QACA,IAAMC,EAAE,GAAG,IAAID,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAYV,OAAO,CAAlC,CAAeU,CAAf;QACA,IAAME,IAAI,GAAG,CAACN,EAAE,GAAH,GAAA,IAAb,CAAA;QACA,IAAMO,IAAI,GAAG,CAACL,EAAE,GAAH,GAAA,IAAb,CAAA;QACA,IAAMM,IAAI,GAAGJ,IAAI,CAAJA,KAAAA,CAAW,CAACC,EAAE,GAAFA,IAAAA,GAAD,GAAA,IAAxB,KAAaD,CAAb;QACA,IAAMK,IAAI,GAAGL,IAAI,CAAJA,KAAAA,CAAW,CAACC,EAAE,GAAFA,IAAAA,GAAD,GAAA,IAAxB,MAAaD,CAAb;QACA,IAAMM,KAAK,GAAGb,MAAM,CAANA,aAAAA,CAAAA,IAAAA,EAAd,IAAcA,CAAd;;QAEA,KAAI,CAAJ,aAAA,CAAA,KAAA,EAAA,CAAA,EAAA,CAAA;MAXFA,CAAAA;MAcA;;MACA,KAAA,aAAA,CACEA,MAAM,CAANA,aAAAA,CAAqBC,KAAK,GAA1BD,CAAAA,EAAgCE,MAAM,GADxC,CACEF,CADF,EAEEC,KAAK,GAFP,CAAA,EAGEC,MAAM,GAHR,CAAA;;MAMA,IAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;QACrBH,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;MACD;;MAED,OAAA,IAAA;IACD;EApCmB,CAAP","sourcesContent":["import { isNodePattern } from '@jimp/utils';\n\n/**\n * Creates a circle out of an image.\n * @param {object} options (optional) r: radius of effect\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  fisheye(options = { r: 2.5 }, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = { r: 2.5 };\n    }\n\n    const source = this.cloneQuiet();\n    const { width, height } = source.bitmap;\n\n    source.scanQuiet(0, 0, width, height, (x, y) => {\n      const hx = x / width;\n      const hy = y / height;\n      const r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));\n      const rn = 2 * Math.pow(r, options.r);\n      const cosA = (hx - 0.5) / r;\n      const sinA = (hy - 0.5) / r;\n      const newX = Math.round((rn * cosA + 0.5) * width);\n      const newY = Math.round((rn * sinA + 0.5) * height);\n      const color = source.getPixelColor(newX, newY);\n\n      this.setPixelColor(color, x, y);\n    });\n\n    /* Set center pixel color, otherwise it will be transparent */\n    this.setPixelColor(\n      source.getPixelColor(width / 2, height / 2),\n      width / 2,\n      height / 2\n    );\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}