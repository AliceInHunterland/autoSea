{"ast":null,"code":"var __defProp = Object.defineProperty;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n  return value;\n}; // src/constants/index.ts\n\n\nvar constants_exports = {};\n\n__export(constants_exports, {\n  bt709: () => bt709_exports\n}); // src/constants/bt709.ts\n\n\nvar bt709_exports = {};\n\n__export(bt709_exports, {\n  Y: () => Y,\n  x: () => x,\n  y: () => y\n});\n\nvar Y = /* @__PURE__ */(Y2 => {\n  Y2[Y2[\"RED\"] = 0.2126] = \"RED\";\n  Y2[Y2[\"GREEN\"] = 0.7152] = \"GREEN\";\n  Y2[Y2[\"BLUE\"] = 0.0722] = \"BLUE\";\n  Y2[Y2[\"WHITE\"] = 1] = \"WHITE\";\n  return Y2;\n})(Y || {});\n\nvar x = /* @__PURE__ */(x2 => {\n  x2[x2[\"RED\"] = 0.64] = \"RED\";\n  x2[x2[\"GREEN\"] = 0.3] = \"GREEN\";\n  x2[x2[\"BLUE\"] = 0.15] = \"BLUE\";\n  x2[x2[\"WHITE\"] = 0.3127] = \"WHITE\";\n  return x2;\n})(x || {});\n\nvar y = /* @__PURE__ */(y2 => {\n  y2[y2[\"RED\"] = 0.33] = \"RED\";\n  y2[y2[\"GREEN\"] = 0.6] = \"GREEN\";\n  y2[y2[\"BLUE\"] = 0.06] = \"BLUE\";\n  y2[y2[\"WHITE\"] = 0.329] = \"WHITE\";\n  return y2;\n})(y || {}); // src/conversion/index.ts\n\n\nvar conversion_exports = {};\n\n__export(conversion_exports, {\n  lab2rgb: () => lab2rgb,\n  lab2xyz: () => lab2xyz,\n  rgb2hsl: () => rgb2hsl,\n  rgb2lab: () => rgb2lab,\n  rgb2xyz: () => rgb2xyz,\n  xyz2lab: () => xyz2lab,\n  xyz2rgb: () => xyz2rgb\n}); // src/conversion/rgb2xyz.ts\n\n\nfunction correctGamma(n) {\n  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;\n}\n\nfunction rgb2xyz(r, g, b) {\n  r = correctGamma(r / 255);\n  g = correctGamma(g / 255);\n  b = correctGamma(b / 255);\n  return {\n    x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n    y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n    z: r * 0.0193 + g * 0.1192 + b * 0.9505\n  };\n} // src/utils/arithmetic.ts\n\n\nvar arithmetic_exports = {};\n\n__export(arithmetic_exports, {\n  degrees2radians: () => degrees2radians,\n  inRange0to255: () => inRange0to255,\n  inRange0to255Rounded: () => inRange0to255Rounded,\n  intInRange: () => intInRange,\n  max3: () => max3,\n  min3: () => min3,\n  stableSort: () => stableSort\n});\n\nfunction degrees2radians(n) {\n  return n * (Math.PI / 180);\n}\n\nfunction max3(a, b, c) {\n  let m = a;\n  if (m < b) m = b;\n  if (m < c) m = c;\n  return m;\n}\n\nfunction min3(a, b, c) {\n  let m = a;\n  if (m > b) m = b;\n  if (m > c) m = c;\n  return m;\n}\n\nfunction intInRange(value, low, high) {\n  if (value > high) value = high;\n  if (value < low) value = low;\n  return value | 0;\n}\n\nfunction inRange0to255Rounded(n) {\n  n = Math.round(n);\n  if (n > 255) n = 255;else if (n < 0) n = 0;\n  return n;\n}\n\nfunction inRange0to255(n) {\n  if (n > 255) n = 255;else if (n < 0) n = 0;\n  return n;\n}\n\nfunction stableSort(arrayToSort, callback) {\n  const type = typeof arrayToSort[0];\n  let sorted;\n\n  if (type === \"number\" || type === \"string\") {\n    const ord = /* @__PURE__ */Object.create(null);\n\n    for (let i = 0, l = arrayToSort.length; i < l; i++) {\n      const val = arrayToSort[i];\n      if (ord[val] || ord[val] === 0) continue;\n      ord[val] = i;\n    }\n\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);\n  } else {\n    const ord2 = arrayToSort.slice(0);\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b));\n  }\n\n  return sorted;\n} // src/conversion/rgb2hsl.ts\n\n\nfunction rgb2hsl(r, g, b) {\n  const min = min3(r, g, b);\n  const max = max3(r, g, b);\n  const delta = max - min;\n  const l = (min + max) / 510;\n  let s = 0;\n  if (l > 0 && l < 1) s = delta / (l < 0.5 ? max + min : 510 - max - min);\n  let h = 0;\n\n  if (delta > 0) {\n    if (max === r) {\n      h = (g - b) / delta;\n    } else if (max === g) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n\n    h *= 60;\n    if (h < 0) h += 360;\n  }\n\n  return {\n    h,\n    s,\n    l\n  };\n} // src/conversion/xyz2lab.ts\n\n\nvar refX = 0.95047;\nvar refY = 1;\nvar refZ = 1.08883;\n\nfunction pivot(n) {\n  return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;\n}\n\nfunction xyz2lab(x2, y2, z) {\n  x2 = pivot(x2 / refX);\n  y2 = pivot(y2 / refY);\n  z = pivot(z / refZ);\n  if (116 * y2 - 16 < 0) throw new Error(\"xxx\");\n  return {\n    L: Math.max(0, 116 * y2 - 16),\n    a: 500 * (x2 - y2),\n    b: 200 * (y2 - z)\n  };\n} // src/conversion/rgb2lab.ts\n\n\nfunction rgb2lab(r, g, b) {\n  const xyz = rgb2xyz(r, g, b);\n  return xyz2lab(xyz.x, xyz.y, xyz.z);\n} // src/conversion/lab2xyz.ts\n\n\nvar refX2 = 0.95047;\nvar refY2 = 1;\nvar refZ2 = 1.08883;\n\nfunction pivot2(n) {\n  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;\n}\n\nfunction lab2xyz(L, a, b) {\n  const y2 = (L + 16) / 116;\n  const x2 = a / 500 + y2;\n  const z = y2 - b / 200;\n  return {\n    x: refX2 * pivot2(x2),\n    y: refY2 * pivot2(y2),\n    z: refZ2 * pivot2(z)\n  };\n} // src/conversion/xyz2rgb.ts\n\n\nfunction correctGamma2(n) {\n  return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;\n}\n\nfunction xyz2rgb(x2, y2, z) {\n  const r = correctGamma2(x2 * 3.2406 + y2 * -1.5372 + z * -0.4986);\n  const g = correctGamma2(x2 * -0.9689 + y2 * 1.8758 + z * 0.0415);\n  const b = correctGamma2(x2 * 0.0557 + y2 * -0.204 + z * 1.057);\n  return {\n    r: inRange0to255Rounded(r * 255),\n    g: inRange0to255Rounded(g * 255),\n    b: inRange0to255Rounded(b * 255)\n  };\n} // src/conversion/lab2rgb.ts\n\n\nfunction lab2rgb(L, a, b) {\n  const xyz = lab2xyz(L, a, b);\n  return xyz2rgb(xyz.x, xyz.y, xyz.z);\n} // src/distance/index.ts\n\n\nvar distance_exports = {};\n\n__export(distance_exports, {\n  AbstractDistanceCalculator: () => AbstractDistanceCalculator,\n  AbstractEuclidean: () => AbstractEuclidean,\n  AbstractManhattan: () => AbstractManhattan,\n  CIE94GraphicArts: () => CIE94GraphicArts,\n  CIE94Textiles: () => CIE94Textiles,\n  CIEDE2000: () => CIEDE2000,\n  CMetric: () => CMetric,\n  Euclidean: () => Euclidean,\n  EuclideanBT709: () => EuclideanBT709,\n  EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,\n  Manhattan: () => Manhattan,\n  ManhattanBT709: () => ManhattanBT709,\n  ManhattanNommyde: () => ManhattanNommyde,\n  PNGQuant: () => PNGQuant\n}); // src/distance/distanceCalculator.ts\n\n\nvar AbstractDistanceCalculator = class {\n  constructor() {\n    __publicField(this, \"_maxDistance\");\n\n    __publicField(this, \"_whitePoint\");\n\n    this._setDefaults();\n\n    this.setWhitePoint(255, 255, 255, 255);\n  }\n\n  setWhitePoint(r, g, b, a) {\n    this._whitePoint = {\n      r: r > 0 ? 255 / r : 0,\n      g: g > 0 ? 255 / g : 0,\n      b: b > 0 ? 255 / b : 0,\n      a: a > 0 ? 255 / a : 0\n    };\n    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n  }\n\n  calculateNormalized(colorA, colorB) {\n    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\n  }\n\n}; // src/distance/cie94.ts\n\nvar AbstractCIE94 = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));\n    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\n    const dL = lab1.L - lab2.L;\n    const dA = lab1.a - lab2.a;\n    const dB = lab1.b - lab2.b;\n    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\n    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\n    const dC = c1 - c2;\n    let deltaH = dA * dA + dB * dB - dC * dC;\n    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n    return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);\n  }\n\n};\nvar CIE94Textiles = class extends AbstractCIE94 {\n  _setDefaults() {\n    this._Kl = 2;\n    this._K1 = 0.048;\n    this._K2 = 0.014;\n    this._kA = 0.25 * 50 / 255;\n  }\n\n};\nvar CIE94GraphicArts = class extends AbstractCIE94 {\n  _setDefaults() {\n    this._Kl = 1;\n    this._K1 = 0.045;\n    this._K2 = 0.015;\n    this._kA = 0.25 * 100 / 255;\n  }\n\n}; // src/distance/ciede2000.ts\n\nvar _CIEDE2000 = class extends AbstractDistanceCalculator {\n  _setDefaults() {}\n\n  static _calculatehp(b, ap) {\n    const hp = Math.atan2(b, ap);\n    if (hp >= 0) return hp;\n    return hp + _CIEDE2000._deg360InRad;\n  }\n\n  static _calculateRT(ahp, aCp) {\n    const aCp_to_7 = aCp ** 7;\n    const R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7));\n    const delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));\n    return -Math.sin(2 * delta_theta) * R_C;\n  }\n\n  static _calculateT(ahp) {\n    return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(ahp * 4 - _CIEDE2000._deg63InRad);\n  }\n\n  static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {\n    const hpSum = h1p + h2p;\n    if (C1pC2p === 0) return hpSum;\n    if (h_bar <= _CIEDE2000._deg180InRad) return hpSum / 2;\n\n    if (hpSum < _CIEDE2000._deg360InRad) {\n      return (hpSum + _CIEDE2000._deg360InRad) / 2;\n    }\n\n    return (hpSum - _CIEDE2000._deg360InRad) / 2;\n  }\n\n  static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {\n    let dhp;\n\n    if (C1pC2p === 0) {\n      dhp = 0;\n    } else if (h_bar <= _CIEDE2000._deg180InRad) {\n      dhp = h2p - h1p;\n    } else if (h2p <= h1p) {\n      dhp = h2p - h1p + _CIEDE2000._deg360InRad;\n    } else {\n      dhp = h2p - h1p - _CIEDE2000._deg360InRad;\n    }\n\n    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);\n  }\n\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b));\n    const lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\n    const dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA;\n    const dE2 = this.calculateRawInLab(lab1, lab2);\n    return Math.sqrt(dE2 + dA * dA);\n  }\n\n  calculateRawInLab(Lab1, Lab2) {\n    const L1 = Lab1.L;\n    const a1 = Lab1.a;\n    const b1 = Lab1.b;\n    const L2 = Lab2.L;\n    const a2 = Lab2.a;\n    const b2 = Lab2.b;\n    const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n    const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2) ** 7;\n    const G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7)));\n    const a1p = (1 + G) * a1;\n    const a2p = (1 + G) * a2;\n    const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n    const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n    const C1pC2p = C1p * C2p;\n\n    const h1p = _CIEDE2000._calculatehp(b1, a1p);\n\n    const h2p = _CIEDE2000._calculatehp(b2, a2p);\n\n    const h_bar = Math.abs(h1p - h2p);\n    const dLp = L2 - L1;\n    const dCp = C2p - C1p;\n\n    const dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\n\n    const ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\n\n    const T = _CIEDE2000._calculateT(ahp);\n\n    const aCp = (C1p + C2p) / 2;\n    const aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2;\n    const S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square);\n    const S_C = 1 + 0.045 * aCp;\n    const S_H = 1 + 0.015 * T * aCp;\n\n    const R_T = _CIEDE2000._calculateRT(ahp, aCp);\n\n    const dLpSL = dLp / S_L;\n    const dCpSC = dCp / S_C;\n    const dHpSH = dHp / S_H;\n    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;\n  }\n\n};\n\nvar CIEDE2000 = _CIEDE2000;\n\n__publicField(CIEDE2000, \"_kA\", 0.25 * 100 / 255);\n\n__publicField(CIEDE2000, \"_pow25to7\", 25 ** 7);\n\n__publicField(CIEDE2000, \"_deg360InRad\", degrees2radians(360));\n\n__publicField(CIEDE2000, \"_deg180InRad\", degrees2radians(180));\n\n__publicField(CIEDE2000, \"_deg30InRad\", degrees2radians(30));\n\n__publicField(CIEDE2000, \"_deg6InRad\", degrees2radians(6));\n\n__publicField(CIEDE2000, \"_deg63InRad\", degrees2radians(63));\n\n__publicField(CIEDE2000, \"_deg275InRad\", degrees2radians(275));\n\n__publicField(CIEDE2000, \"_deg25InRad\", degrees2radians(25)); // src/distance/cmetric.ts\n\n\nvar CMetric = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const rmean = (r1 + r2) / 2 * this._whitePoint.r;\n    const r = (r1 - r2) * this._whitePoint.r;\n    const g = (g1 - g2) * this._whitePoint.g;\n    const b = (b1 - b2) * this._whitePoint.b;\n    const dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8);\n    const dA = (a2 - a1) * this._whitePoint.a;\n    return Math.sqrt(dE + dA * dA);\n  }\n\n  _setDefaults() {}\n\n}; // src/distance/euclidean.ts\n\nvar AbstractEuclidean = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const dR = r2 - r1;\n    const dG = g2 - g1;\n    const dB = b2 - b1;\n    const dA = a2 - a1;\n    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\n  }\n\n};\nvar Euclidean = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n\n};\nvar EuclideanBT709 = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 0.2126\n    /* RED */\n    ;\n    this._kG = 0.7152\n    /* GREEN */\n    ;\n    this._kB = 0.0722\n    /* BLUE */\n    ;\n    this._kA = 1;\n  }\n\n};\nvar EuclideanBT709NoAlpha = class extends AbstractEuclidean {\n  _setDefaults() {\n    this._kR = 0.2126\n    /* RED */\n    ;\n    this._kG = 0.7152\n    /* GREEN */\n    ;\n    this._kB = 0.0722\n    /* BLUE */\n    ;\n    this._kA = 0;\n  }\n\n}; // src/distance/manhattan.ts\n\nvar AbstractManhattan = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    let dR = r2 - r1;\n    let dG = g2 - g1;\n    let dB = b2 - b1;\n    let dA = a2 - a1;\n    if (dR < 0) dR = 0 - dR;\n    if (dG < 0) dG = 0 - dG;\n    if (dB < 0) dB = 0 - dB;\n    if (dA < 0) dA = 0 - dA;\n    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n  }\n\n};\nvar Manhattan = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n\n};\nvar ManhattanNommyde = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 0.4984;\n    this._kG = 0.8625;\n    this._kB = 0.2979;\n    this._kA = 1;\n  }\n\n};\nvar ManhattanBT709 = class extends AbstractManhattan {\n  _setDefaults() {\n    this._kR = 0.2126\n    /* RED */\n    ;\n    this._kG = 0.7152\n    /* GREEN */\n    ;\n    this._kB = 0.0722\n    /* BLUE */\n    ;\n    this._kA = 1;\n  }\n\n}; // src/distance/pngQuant.ts\n\nvar PNGQuant = class extends AbstractDistanceCalculator {\n  calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {\n    const alphas = (a2 - a1) * this._whitePoint.a;\n    return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\n  }\n\n  _colordifferenceCh(x2, y2, alphas) {\n    const black = x2 - y2;\n    const white = black + alphas;\n    return black * black + white * white;\n  }\n\n  _setDefaults() {}\n\n}; // src/palette/index.ts\n\nvar palette_exports = {};\n\n__export(palette_exports, {\n  AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,\n  ColorHistogram: () => ColorHistogram,\n  NeuQuant: () => NeuQuant,\n  NeuQuantFloat: () => NeuQuantFloat,\n  RGBQuant: () => RGBQuant,\n  WuColorCube: () => WuColorCube,\n  WuQuant: () => WuQuant\n}); // src/palette/paletteQuantizer.ts\n\n\nvar AbstractPaletteQuantizer = class {\n  quantizeSync() {\n    for (const value of this.quantize()) {\n      if (value.palette) {\n        return value.palette;\n      }\n    }\n\n    throw new Error(\"unreachable\");\n  }\n\n}; // src/utils/point.ts\n\nvar Point = class {\n  constructor() {\n    __publicField(this, \"r\");\n\n    __publicField(this, \"g\");\n\n    __publicField(this, \"b\");\n\n    __publicField(this, \"a\");\n\n    __publicField(this, \"uint32\");\n\n    __publicField(this, \"rgba\");\n\n    this.uint32 = -1 >>> 0;\n    this.r = this.g = this.b = this.a = 0;\n    this.rgba = new Array(4);\n    this.rgba[0] = 0;\n    this.rgba[1] = 0;\n    this.rgba[2] = 0;\n    this.rgba[3] = 0;\n  }\n\n  static createByQuadruplet(quadruplet) {\n    const point = new Point();\n    point.r = quadruplet[0] | 0;\n    point.g = quadruplet[1] | 0;\n    point.b = quadruplet[2] | 0;\n    point.a = quadruplet[3] | 0;\n\n    point._loadUINT32();\n\n    point._loadQuadruplet();\n\n    return point;\n  }\n\n  static createByRGBA(red, green, blue, alpha) {\n    const point = new Point();\n    point.r = red | 0;\n    point.g = green | 0;\n    point.b = blue | 0;\n    point.a = alpha | 0;\n\n    point._loadUINT32();\n\n    point._loadQuadruplet();\n\n    return point;\n  }\n\n  static createByUint32(uint32) {\n    const point = new Point();\n    point.uint32 = uint32 >>> 0;\n\n    point._loadRGBA();\n\n    point._loadQuadruplet();\n\n    return point;\n  }\n\n  from(point) {\n    this.r = point.r;\n    this.g = point.g;\n    this.b = point.b;\n    this.a = point.a;\n    this.uint32 = point.uint32;\n    this.rgba[0] = point.r;\n    this.rgba[1] = point.g;\n    this.rgba[2] = point.b;\n    this.rgba[3] = point.a;\n  }\n\n  getLuminosity(useAlphaChannel) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n\n    if (useAlphaChannel) {\n      r = Math.min(255, 255 - this.a + this.a * r / 255);\n      g = Math.min(255, 255 - this.a + this.a * g / 255);\n      b = Math.min(255, 255 - this.a + this.a * b / 255);\n    }\n\n    return r * 0.2126\n    /* RED */\n    + g * 0.7152\n    /* GREEN */\n    + b * 0.0722\n    /* BLUE */\n    ;\n  }\n\n  _loadUINT32() {\n    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\n  }\n\n  _loadRGBA() {\n    this.r = this.uint32 & 255;\n    this.g = this.uint32 >>> 8 & 255;\n    this.b = this.uint32 >>> 16 & 255;\n    this.a = this.uint32 >>> 24 & 255;\n  }\n\n  _loadQuadruplet() {\n    this.rgba[0] = this.r;\n    this.rgba[1] = this.g;\n    this.rgba[2] = this.b;\n    this.rgba[3] = this.a;\n  }\n\n}; // src/utils/pointContainer.ts\n\nvar PointContainer = class {\n  constructor() {\n    __publicField(this, \"_pointArray\");\n\n    __publicField(this, \"_width\");\n\n    __publicField(this, \"_height\");\n\n    this._width = 0;\n    this._height = 0;\n    this._pointArray = [];\n  }\n\n  getWidth() {\n    return this._width;\n  }\n\n  getHeight() {\n    return this._height;\n  }\n\n  setWidth(width) {\n    this._width = width;\n  }\n\n  setHeight(height) {\n    this._height = height;\n  }\n\n  getPointArray() {\n    return this._pointArray;\n  }\n\n  clone() {\n    const clone = new PointContainer();\n    clone._width = this._width;\n    clone._height = this._height;\n\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      clone._pointArray[i] = Point.createByUint32(this._pointArray[i].uint32 | 0);\n    }\n\n    return clone;\n  }\n\n  toUint32Array() {\n    const l = this._pointArray.length;\n    const uint32Array = new Uint32Array(l);\n\n    for (let i = 0; i < l; i++) {\n      uint32Array[i] = this._pointArray[i].uint32;\n    }\n\n    return uint32Array;\n  }\n\n  toUint8Array() {\n    return new Uint8Array(this.toUint32Array().buffer);\n  }\n\n  static fromHTMLImageElement(img) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n    return PointContainer.fromHTMLCanvasElement(canvas);\n  }\n\n  static fromHTMLCanvasElement(canvas) {\n    const width = canvas.width;\n    const height = canvas.height;\n    const ctx = canvas.getContext(\"2d\");\n    const imgData = ctx.getImageData(0, 0, width, height);\n    return PointContainer.fromImageData(imgData);\n  }\n\n  static fromImageData(imageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n    return PointContainer.fromUint8Array(imageData.data, width, height);\n  }\n\n  static fromUint8Array(uint8Array, width, height) {\n    switch (Object.prototype.toString.call(uint8Array)) {\n      case \"[object Uint8ClampedArray]\":\n      case \"[object Uint8Array]\":\n        break;\n\n      default:\n        uint8Array = new Uint8Array(uint8Array);\n    }\n\n    const uint32Array = new Uint32Array(uint8Array.buffer);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n\n  static fromUint32Array(uint32Array, width, height) {\n    const container = new PointContainer();\n    container._width = width;\n    container._height = height;\n\n    for (let i = 0, l = uint32Array.length; i < l; i++) {\n      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0);\n    }\n\n    return container;\n  }\n\n  static fromBuffer(buffer, width, height) {\n    const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n\n}; // src/utils/palette.ts\n\nvar hueGroups = 10;\n\nfunction hueGroup(hue, segmentsNumber) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg) return i;\n  }\n\n  return 0;\n}\n\nvar Palette = class {\n  constructor() {\n    __publicField(this, \"_pointContainer\");\n\n    __publicField(this, \"_pointArray\", []);\n\n    __publicField(this, \"_i32idx\", {});\n\n    this._pointContainer = new PointContainer();\n\n    this._pointContainer.setHeight(1);\n\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n\n  add(color) {\n    this._pointArray.push(color);\n\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n\n  has(color) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32) return true;\n    }\n\n    return false;\n  }\n\n  getNearestColor(colorDistanceCalculator, color) {\n    return this._pointArray[this._getNearestIndex(colorDistanceCalculator, color) | 0];\n  }\n\n  getPointContainer() {\n    return this._pointContainer;\n  }\n\n  _nearestPointFromCache(key) {\n    return typeof this._i32idx[key] === \"number\" ? this._i32idx[key] : -1;\n  }\n\n  _getNearestIndex(colorDistanceCalculator, point) {\n    let idx = this._nearestPointFromCache(\"\" + point.uint32);\n\n    if (idx >= 0) return idx;\n    let minimalDistance = Number.MAX_VALUE;\n    idx = 0;\n\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\n\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n\n  sort() {\n    this._i32idx = {};\n\n    this._pointArray.sort((a, b) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n      const hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      const hueDiff = hueB - hueA;\n      if (hueDiff) return -hueDiff;\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n      if (lB - lA !== 0) return lB - lA;\n      const satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);\n      if (satDiff) return -satDiff;\n      return 0;\n    });\n  }\n\n}; // src/utils/index.ts\n\nvar utils_exports = {};\n\n__export(utils_exports, {\n  HueStatistics: () => HueStatistics,\n  Palette: () => Palette,\n  Point: () => Point,\n  PointContainer: () => PointContainer,\n  ProgressTracker: () => ProgressTracker,\n  arithmetic: () => arithmetic_exports\n}); // src/utils/hueStatistics.ts\n\n\nvar HueGroup = class {\n  constructor() {\n    __publicField(this, \"num\", 0);\n\n    __publicField(this, \"cols\", []);\n  }\n\n};\nvar HueStatistics = class {\n  constructor(numGroups, minCols) {\n    __publicField(this, \"_numGroups\");\n\n    __publicField(this, \"_minCols\");\n\n    __publicField(this, \"_stats\");\n\n    __publicField(this, \"_groupsFull\");\n\n    this._numGroups = numGroups;\n    this._minCols = minCols;\n    this._stats = [];\n\n    for (let i = 0; i <= numGroups; i++) {\n      this._stats[i] = new HueGroup();\n    }\n\n    this._groupsFull = 0;\n  }\n\n  check(i32) {\n    if (this._groupsFull === this._numGroups + 1) {\n      this.check = () => {};\n    }\n\n    const r = i32 & 255;\n    const g = i32 >>> 8 & 255;\n    const b = i32 >>> 16 & 255;\n    const hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);\n    const gr = this._stats[hg];\n    const min = this._minCols;\n    gr.num++;\n\n    if (gr.num > min) {\n      return;\n    }\n\n    if (gr.num === min) {\n      this._groupsFull++;\n    }\n\n    if (gr.num <= min) {\n      this._stats[hg].cols.push(i32);\n    }\n  }\n\n  injectIntoDictionary(histG) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach(col => {\n          if (!histG[col]) {\n            histG[col] = 1;\n          } else {\n            histG[col]++;\n          }\n        });\n      }\n    }\n  }\n\n  injectIntoArray(histG) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach(col => {\n          if (histG.indexOf(col) === -1) {\n            histG.push(col);\n          }\n        });\n      }\n    }\n  }\n\n}; // src/utils/progressTracker.ts\n\nvar _ProgressTracker = class {\n  constructor(valueRange, progressRange) {\n    __publicField(this, \"progress\");\n\n    __publicField(this, \"_step\");\n\n    __publicField(this, \"_range\");\n\n    __publicField(this, \"_last\");\n\n    __publicField(this, \"_progressRange\");\n\n    this._range = valueRange;\n    this._progressRange = progressRange;\n    this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0);\n    this._last = -this._step;\n    this.progress = 0;\n  }\n\n  shouldNotify(current) {\n    if (current - this._last >= this._step) {\n      this._last = current;\n      this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange);\n      return true;\n    }\n\n    return false;\n  }\n\n};\n\nvar ProgressTracker = _ProgressTracker;\n\n__publicField(ProgressTracker, \"steps\", 100); // src/palette/neuquant/neuquant.ts\n\n\nvar networkBiasShift = 3;\nvar Neuron = class {\n  constructor(defaultValue) {\n    __publicField(this, \"r\");\n\n    __publicField(this, \"g\");\n\n    __publicField(this, \"b\");\n\n    __publicField(this, \"a\");\n\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  toPoint() {\n    return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\n  }\n\n  subtract(r, g, b, a) {\n    this.r -= r | 0;\n    this.g -= g | 0;\n    this.b -= b | 0;\n    this.a -= a | 0;\n  }\n\n};\n\nvar _NeuQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator) {\n    let colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n    super();\n\n    __publicField(this, \"_pointArray\");\n\n    __publicField(this, \"_networkSize\");\n\n    __publicField(this, \"_network\");\n\n    __publicField(this, \"_sampleFactor\");\n\n    __publicField(this, \"_radPower\");\n\n    __publicField(this, \"_freq\");\n\n    __publicField(this, \"_bias\");\n\n    __publicField(this, \"_distance\");\n\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\n  }\n\n  sample(pointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize() {\n    this._init();\n\n    yield* this._learn();\n    yield {\n      palette: this._buildPalette(),\n      progress: 100\n    };\n  }\n\n  _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);\n      this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0;\n      this._bias[i] = 0;\n    }\n  }\n\n  *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < _NeuQuant._minpicturebytes) sampleFactor = 1;\n    const alphadec = 30 + (sampleFactor - 1) / 3 | 0;\n    const pointsToSample = pointsNumber / sampleFactor | 0;\n    let delta = pointsToSample / _NeuQuant._nCycles | 0;\n    let alpha = _NeuQuant._initAlpha;\n    let radius = (this._networkSize >> 3) * _NeuQuant._radiusBias;\n    let rad = radius >> _NeuQuant._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;\n    }\n\n    let step;\n\n    if (pointsNumber < _NeuQuant._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % _NeuQuant._prime1 !== 0) {\n      step = _NeuQuant._prime1;\n    } else if (pointsNumber % _NeuQuant._prime2 !== 0) {\n      step = _NeuQuant._prime2;\n    } else if (pointsNumber % _NeuQuant._prime3 !== 0) {\n      step = _NeuQuant._prime3;\n    } else {\n      step = _NeuQuant._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n\n    for (let i = 0, pointIndex = 0; i < pointsToSample;) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec | 0;\n        radius -= radius / _NeuQuant._radiusDecrease | 0;\n        rad = radius >> _NeuQuant._radiusBiasShift;\n        if (rad <= 1) rad = 0;\n\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;\n        }\n      }\n    }\n  }\n\n  _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach(neuron => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  _alterNeighbour(rad, i, b, g, r, al) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / _NeuQuant._alphaRadBias;\n\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  _alterSingle(alpha, i, b, g, r, a) {\n    alpha /= _NeuQuant._initAlpha;\n    const n = this._network[i];\n    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n  }\n\n  _contest(b, g, r, a) {\n    const multiplier = 255 * 4 << networkBiasShift;\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist = this._distance.calculateNormalized(n, {\n        r,\n        g,\n        b,\n        a\n      }) * multiplier | 0;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - networkBiasShift);\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      const betafreq = this._freq[i] >> _NeuQuant._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << _NeuQuant._gammaShift;\n    }\n\n    this._freq[bestpos] += _NeuQuant._beta;\n    this._bias[bestpos] -= _NeuQuant._betaGamma;\n    return bestbiaspos;\n  }\n\n};\n\nvar NeuQuant = _NeuQuant;\n\n__publicField(NeuQuant, \"_prime1\", 499);\n\n__publicField(NeuQuant, \"_prime2\", 491);\n\n__publicField(NeuQuant, \"_prime3\", 487);\n\n__publicField(NeuQuant, \"_prime4\", 503);\n\n__publicField(NeuQuant, \"_minpicturebytes\", _NeuQuant._prime4);\n\n__publicField(NeuQuant, \"_nCycles\", 100);\n\n__publicField(NeuQuant, \"_initialBiasShift\", 16);\n\n__publicField(NeuQuant, \"_initialBias\", 1 << _NeuQuant._initialBiasShift);\n\n__publicField(NeuQuant, \"_gammaShift\", 10);\n\n__publicField(NeuQuant, \"_betaShift\", 10);\n\n__publicField(NeuQuant, \"_beta\", _NeuQuant._initialBias >> _NeuQuant._betaShift);\n\n__publicField(NeuQuant, \"_betaGamma\", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift);\n\n__publicField(NeuQuant, \"_radiusBiasShift\", 6);\n\n__publicField(NeuQuant, \"_radiusBias\", 1 << _NeuQuant._radiusBiasShift);\n\n__publicField(NeuQuant, \"_radiusDecrease\", 30);\n\n__publicField(NeuQuant, \"_alphaBiasShift\", 10);\n\n__publicField(NeuQuant, \"_initAlpha\", 1 << _NeuQuant._alphaBiasShift);\n\n__publicField(NeuQuant, \"_radBiasShift\", 8);\n\n__publicField(NeuQuant, \"_radBias\", 1 << _NeuQuant._radBiasShift);\n\n__publicField(NeuQuant, \"_alphaRadBiasShift\", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift);\n\n__publicField(NeuQuant, \"_alphaRadBias\", 1 << _NeuQuant._alphaRadBiasShift); // src/palette/neuquant/neuquantFloat.ts\n\n\nvar networkBiasShift2 = 3;\nvar NeuronFloat = class {\n  constructor(defaultValue) {\n    __publicField(this, \"r\");\n\n    __publicField(this, \"g\");\n\n    __publicField(this, \"b\");\n\n    __publicField(this, \"a\");\n\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  toPoint() {\n    return Point.createByRGBA(this.r >> networkBiasShift2, this.g >> networkBiasShift2, this.b >> networkBiasShift2, this.a >> networkBiasShift2);\n  }\n\n  subtract(r, g, b, a) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n\n};\n\nvar _NeuQuantFloat = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator) {\n    let colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n    super();\n\n    __publicField(this, \"_pointArray\");\n\n    __publicField(this, \"_networkSize\");\n\n    __publicField(this, \"_network\");\n\n    __publicField(this, \"_sampleFactor\");\n\n    __publicField(this, \"_radPower\");\n\n    __publicField(this, \"_freq\");\n\n    __publicField(this, \"_bias\");\n\n    __publicField(this, \"_distance\");\n\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2, 255 << networkBiasShift2);\n  }\n\n  sample(pointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize() {\n    this._init();\n\n    yield* this._learn();\n    yield {\n      palette: this._buildPalette(),\n      progress: 100\n    };\n  }\n\n  _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat((i << networkBiasShift2 + 8) / this._networkSize);\n      this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n\n  *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < _NeuQuantFloat._minpicturebytes) sampleFactor = 1;\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n    let delta = pointsToSample / _NeuQuantFloat._nCycles | 0;\n    let alpha = _NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias;\n    let rad = radius >> _NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));\n    }\n\n    let step;\n\n    if (pointsNumber < _NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % _NeuQuantFloat._prime1 !== 0) {\n      step = _NeuQuantFloat._prime1;\n    } else if (pointsNumber % _NeuQuantFloat._prime2 !== 0) {\n      step = _NeuQuantFloat._prime2;\n    } else if (pointsNumber % _NeuQuantFloat._prime3 !== 0) {\n      step = _NeuQuantFloat._prime3;\n    } else {\n      step = _NeuQuantFloat._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n\n    for (let i = 0, pointIndex = 0; i < pointsToSample;) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift2;\n      const g = point.g << networkBiasShift2;\n      const r = point.r << networkBiasShift2;\n      const a = point.a << networkBiasShift2;\n\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / _NeuQuantFloat._radiusDecrease;\n        rad = radius >> _NeuQuantFloat._radiusBiasShift;\n        if (rad <= 1) rad = 0;\n\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));\n        }\n      }\n    }\n  }\n\n  _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach(neuron => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  _alterNeighbour(rad, i, b, g, r, al) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;\n\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  _alterSingle(alpha, i, b, g, r, a) {\n    alpha /= _NeuQuantFloat._initAlpha;\n    const n = this._network[i];\n    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));\n  }\n\n  _contest(b, g, r, al) {\n    const multiplier = 255 * 4 << networkBiasShift2;\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist = this._distance.calculateNormalized(n, {\n        r,\n        g,\n        b,\n        a: al\n      }) * multiplier;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - networkBiasShift2);\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;\n    }\n\n    this._freq[bestpos] += _NeuQuantFloat._beta;\n    this._bias[bestpos] -= _NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n\n};\n\nvar NeuQuantFloat = _NeuQuantFloat;\n\n__publicField(NeuQuantFloat, \"_prime1\", 499);\n\n__publicField(NeuQuantFloat, \"_prime2\", 491);\n\n__publicField(NeuQuantFloat, \"_prime3\", 487);\n\n__publicField(NeuQuantFloat, \"_prime4\", 503);\n\n__publicField(NeuQuantFloat, \"_minpicturebytes\", _NeuQuantFloat._prime4);\n\n__publicField(NeuQuantFloat, \"_nCycles\", 100);\n\n__publicField(NeuQuantFloat, \"_initialBiasShift\", 16);\n\n__publicField(NeuQuantFloat, \"_initialBias\", 1 << _NeuQuantFloat._initialBiasShift);\n\n__publicField(NeuQuantFloat, \"_gammaShift\", 10);\n\n__publicField(NeuQuantFloat, \"_betaShift\", 10);\n\n__publicField(NeuQuantFloat, \"_beta\", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift);\n\n__publicField(NeuQuantFloat, \"_betaGamma\", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift);\n\n__publicField(NeuQuantFloat, \"_radiusBiasShift\", 6);\n\n__publicField(NeuQuantFloat, \"_radiusBias\", 1 << _NeuQuantFloat._radiusBiasShift);\n\n__publicField(NeuQuantFloat, \"_radiusDecrease\", 30);\n\n__publicField(NeuQuantFloat, \"_alphaBiasShift\", 10);\n\n__publicField(NeuQuantFloat, \"_initAlpha\", 1 << _NeuQuantFloat._alphaBiasShift);\n\n__publicField(NeuQuantFloat, \"_radBiasShift\", 8);\n\n__publicField(NeuQuantFloat, \"_radBias\", 1 << _NeuQuantFloat._radBiasShift);\n\n__publicField(NeuQuantFloat, \"_alphaRadBiasShift\", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift);\n\n__publicField(NeuQuantFloat, \"_alphaRadBias\", 1 << _NeuQuantFloat._alphaRadBiasShift); // src/palette/rgbquant/colorHistogram.ts\n\n\nvar _ColorHistogram = class {\n  constructor(method, colors) {\n    __publicField(this, \"_method\");\n\n    __publicField(this, \"_hueStats\");\n\n    __publicField(this, \"_histogram\");\n\n    __publicField(this, \"_initColors\");\n\n    __publicField(this, \"_minHueCols\");\n\n    this._method = method;\n    this._minHueCols = colors << 2;\n    this._initColors = colors << 2;\n    this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols);\n    this._histogram = /* @__PURE__ */Object.create(null);\n  }\n\n  sample(pointContainer) {\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n\n        break;\n\n      case 2:\n        this._colorStats2D(pointContainer);\n\n        break;\n    }\n  }\n\n  getImportanceSortedColorsIDXI32() {\n    const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[b] - this._histogram[a]);\n\n    if (sorted.length === 0) {\n      return [];\n    }\n\n    let idxi32;\n\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n        idxi32 = sorted.slice(0, initialColorsLimit);\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n\n        this._hueStats.injectIntoArray(idxi32);\n\n        break;\n\n      case 2:\n        idxi32 = sorted;\n        break;\n\n      default:\n        throw new Error(\"Incorrect method\");\n    }\n\n    return idxi32.map(v => +v);\n  }\n\n  _colorStats1D(pointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n\n      this._hueStats.check(col);\n\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n\n  _colorStats2D(pointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n    const boxW = _ColorHistogram._boxSize[0];\n    const boxH = _ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n\n    const histG = this._histogram;\n    boxes.forEach(box => {\n      let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;\n\n      if (effc < 2) effc = 2;\n      const histL = {};\n\n      this._iterateBox(box, width, i => {\n        const col = pointArray[i].uint32;\n\n        this._hueStats.check(col);\n\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n\n    this._hueStats.injectIntoDictionary(histG);\n  }\n\n  _iterateBox(bbox, wid, fn) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n    let cnt = 0;\n    let i = i0;\n\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n\n  _makeBoxes(width, height, stepX, stepY) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n\n    for (let y2 = 0; y2 < height; y2 += stepY) {\n      for (let x2 = 0; x2 < width; x2 += stepX) {\n        boxesArray.push({\n          x: x2,\n          y: y2,\n          w: x2 === xend ? wrem : stepX,\n          h: y2 === yend ? hrem : stepY\n        });\n      }\n    }\n\n    return boxesArray;\n  }\n\n};\n\nvar ColorHistogram = _ColorHistogram;\n\n__publicField(ColorHistogram, \"_boxSize\", [64, 64]);\n\n__publicField(ColorHistogram, \"_boxPixels\", 2);\n\n__publicField(ColorHistogram, \"_hueGroups\", 10); // src/palette/rgbquant/rgbquant.ts\n\n\nvar RemovedColor = class {\n  constructor(index, color, distance) {\n    __publicField(this, \"index\");\n\n    __publicField(this, \"color\");\n\n    __publicField(this, \"distance\");\n\n    this.index = index;\n    this.color = color;\n    this.distance = distance;\n  }\n\n};\nvar RGBQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator) {\n    let colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n    let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n    super();\n\n    __publicField(this, \"_colors\");\n\n    __publicField(this, \"_initialDistance\");\n\n    __publicField(this, \"_distanceIncrement\");\n\n    __publicField(this, \"_histogram\");\n\n    __publicField(this, \"_distance\");\n\n    this._distance = colorDistanceCalculator;\n    this._colors = colors;\n    this._histogram = new ColorHistogram(method, colors);\n    this._initialDistance = 0.01;\n    this._distanceIncrement = 5e-3;\n  }\n\n  sample(image) {\n    this._histogram.sample(image);\n  }\n\n  *quantize() {\n    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n\n    if (idxi32.length === 0) {\n      throw new Error(\"No colors in image\");\n    }\n\n    yield* this._buildPalette(idxi32);\n  }\n\n  *_buildPalette(idxi32) {\n    const palette = new Palette();\n    const colorArray = palette.getPointContainer().getPointArray();\n    const usageArray = new Array(idxi32.length);\n\n    for (let i = 0; i < idxi32.length; i++) {\n      colorArray.push(Point.createByUint32(idxi32[i]));\n      usageArray[i] = 1;\n    }\n\n    const len = colorArray.length;\n    const memDist = [];\n    let palLen = len;\n    let thold = this._initialDistance;\n    const tracker = new ProgressTracker(palLen - this._colors, 99);\n\n    while (palLen > this._colors) {\n      memDist.length = 0;\n\n      for (let i = 0; i < len; i++) {\n        if (tracker.shouldNotify(len - palLen)) {\n          yield {\n            progress: tracker.progress\n          };\n        }\n\n        if (usageArray[i] === 0) continue;\n        const pxi = colorArray[i];\n\n        for (let j = i + 1; j < len; j++) {\n          if (usageArray[j] === 0) continue;\n          const pxj = colorArray[j];\n\n          const dist = this._distance.calculateNormalized(pxi, pxj);\n\n          if (dist < thold) {\n            memDist.push(new RemovedColor(j, pxj, dist));\n            usageArray[j] = 0;\n            palLen--;\n          }\n        }\n      }\n\n      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;\n    }\n\n    if (palLen < this._colors) {\n      stableSort(memDist, (a, b) => b.distance - a.distance);\n      let k = 0;\n\n      while (palLen < this._colors && k < memDist.length) {\n        const removedColor = memDist[k];\n        usageArray[removedColor.index] = 1;\n        palLen++;\n        k++;\n      }\n    }\n\n    let colors = colorArray.length;\n\n    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n      if (usageArray[colorIndex] === 0) {\n        if (colorIndex !== colors - 1) {\n          colorArray[colorIndex] = colorArray[colors - 1];\n        }\n\n        --colors;\n      }\n    }\n\n    colorArray.length = colors;\n    palette.sort();\n    yield {\n      palette,\n      progress: 100\n    };\n  }\n\n}; // src/palette/wu/wuQuant.ts\n\nfunction createArray1D(dimension1) {\n  const a = [];\n\n  for (let k = 0; k < dimension1; k++) {\n    a[k] = 0;\n  }\n\n  return a;\n}\n\nfunction createArray4D(dimension1, dimension2, dimension3, dimension4) {\n  const a = new Array(dimension1);\n\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = new Array(dimension4);\n\n        for (let l = 0; l < dimension4; l++) {\n          a[i][j][k][l] = 0;\n        }\n      }\n    }\n  }\n\n  return a;\n}\n\nfunction createArray3D(dimension1, dimension2, dimension3) {\n  const a = new Array(dimension1);\n\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = 0;\n      }\n    }\n  }\n\n  return a;\n}\n\nfunction fillArray3D(a, dimension1, dimension2, dimension3, value) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = [];\n\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = [];\n\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = value;\n      }\n    }\n  }\n}\n\nfunction fillArray1D(a, dimension1, value) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = value;\n  }\n}\n\nvar WuColorCube = class {\n  constructor() {\n    __publicField(this, \"redMinimum\");\n\n    __publicField(this, \"redMaximum\");\n\n    __publicField(this, \"greenMinimum\");\n\n    __publicField(this, \"greenMaximum\");\n\n    __publicField(this, \"blueMinimum\");\n\n    __publicField(this, \"blueMaximum\");\n\n    __publicField(this, \"volume\");\n\n    __publicField(this, \"alphaMinimum\");\n\n    __publicField(this, \"alphaMaximum\");\n  }\n\n};\n\nvar _WuQuant = class extends AbstractPaletteQuantizer {\n  constructor(colorDistanceCalculator) {\n    let colors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 256;\n    let significantBitsPerChannel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    super();\n\n    __publicField(this, \"_reds\");\n\n    __publicField(this, \"_greens\");\n\n    __publicField(this, \"_blues\");\n\n    __publicField(this, \"_alphas\");\n\n    __publicField(this, \"_sums\");\n\n    __publicField(this, \"_weights\");\n\n    __publicField(this, \"_momentsRed\");\n\n    __publicField(this, \"_momentsGreen\");\n\n    __publicField(this, \"_momentsBlue\");\n\n    __publicField(this, \"_momentsAlpha\");\n\n    __publicField(this, \"_moments\");\n\n    __publicField(this, \"_table\");\n\n    __publicField(this, \"_pixels\");\n\n    __publicField(this, \"_cubes\");\n\n    __publicField(this, \"_colors\");\n\n    __publicField(this, \"_significantBitsPerChannel\");\n\n    __publicField(this, \"_maxSideIndex\");\n\n    __publicField(this, \"_alphaMaxSideIndex\");\n\n    __publicField(this, \"_sideSize\");\n\n    __publicField(this, \"_alphaSideSize\");\n\n    __publicField(this, \"_distance\");\n\n    this._distance = colorDistanceCalculator;\n\n    this._setQuality(significantBitsPerChannel);\n\n    this._initialize(colors);\n  }\n\n  sample(image) {\n    const pointArray = image.getPointArray();\n\n    for (let i = 0, l = pointArray.length; i < l; i++) {\n      this._addColor(pointArray[i]);\n    }\n\n    this._pixels = this._pixels.concat(pointArray);\n  }\n\n  *quantize() {\n    yield* this._preparePalette();\n    const palette = new Palette();\n\n    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n      if (this._sums[paletteIndex] > 0) {\n        const sum = this._sums[paletteIndex];\n        const r = this._reds[paletteIndex] / sum;\n        const g = this._greens[paletteIndex] / sum;\n        const b = this._blues[paletteIndex] / sum;\n        const a = this._alphas[paletteIndex] / sum;\n        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n        palette.add(color);\n      }\n    }\n\n    palette.sort();\n    yield {\n      palette,\n      progress: 100\n    };\n  }\n\n  *_preparePalette() {\n    yield* this._calculateMoments();\n    let next = 0;\n    const volumeVariance = createArray1D(this._colors);\n\n    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;\n        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;\n      } else {\n        volumeVariance[next] = 0;\n        cubeIndex--;\n      }\n\n      next = 0;\n      let temp = volumeVariance[0];\n\n      for (let index = 1; index <= cubeIndex; ++index) {\n        if (volumeVariance[index] > temp) {\n          temp = volumeVariance[index];\n          next = index;\n        }\n      }\n\n      if (temp <= 0) {\n        this._colors = cubeIndex + 1;\n        break;\n      }\n    }\n\n    const lookupRed = [];\n    const lookupGreen = [];\n    const lookupBlue = [];\n    const lookupAlpha = [];\n\n    for (let k = 0; k < this._colors; ++k) {\n      const weight = _WuQuant._volume(this._cubes[k], this._weights);\n\n      if (weight > 0) {\n        lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0;\n        lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0;\n        lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0;\n        lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0;\n      } else {\n        lookupRed[k] = 0;\n        lookupGreen[k] = 0;\n        lookupBlue[k] = 0;\n        lookupAlpha[k] = 0;\n      }\n    }\n\n    this._reds = createArray1D(this._colors + 1);\n    this._greens = createArray1D(this._colors + 1);\n    this._blues = createArray1D(this._colors + 1);\n    this._alphas = createArray1D(this._colors + 1);\n    this._sums = createArray1D(this._colors + 1);\n\n    for (let index = 0, l = this._pixels.length; index < l; index++) {\n      const color = this._pixels[index];\n      const match = -1;\n      let bestMatch = match;\n      let bestDistance = Number.MAX_VALUE;\n\n      for (let lookup = 0; lookup < this._colors; lookup++) {\n        const foundRed = lookupRed[lookup];\n        const foundGreen = lookupGreen[lookup];\n        const foundBlue = lookupBlue[lookup];\n        const foundAlpha = lookupAlpha[lookup];\n\n        const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\n\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = lookup;\n        }\n      }\n\n      this._reds[bestMatch] += color.r;\n      this._greens[bestMatch] += color.g;\n      this._blues[bestMatch] += color.b;\n      this._alphas[bestMatch] += color.a;\n      this._sums[bestMatch]++;\n    }\n  }\n\n  _addColor(color) {\n    const bitsToRemove = 8 - this._significantBitsPerChannel;\n    const indexRed = (color.r >> bitsToRemove) + 1;\n    const indexGreen = (color.g >> bitsToRemove) + 1;\n    const indexBlue = (color.b >> bitsToRemove) + 1;\n    const indexAlpha = (color.a >> bitsToRemove) + 1;\n    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];\n  }\n\n  *_calculateMoments() {\n    const area = [];\n    const areaRed = [];\n    const areaGreen = [];\n    const areaBlue = [];\n    const areaAlpha = [];\n    const area2 = [];\n    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    let trackerProgress = 0;\n    const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);\n\n    for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\n      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\n      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\n\n      for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {\n        if (tracker.shouldNotify(trackerProgress)) {\n          yield {\n            progress: tracker.progress\n          };\n        }\n\n        fillArray1D(area, this._sideSize, 0);\n        fillArray1D(areaRed, this._sideSize, 0);\n        fillArray1D(areaGreen, this._sideSize, 0);\n        fillArray1D(areaBlue, this._sideSize, 0);\n        fillArray1D(areaAlpha, this._sideSize, 0);\n        fillArray1D(area2, this._sideSize, 0);\n\n        for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\n          let line = 0;\n          let lineRed = 0;\n          let lineGreen = 0;\n          let lineBlue = 0;\n          let lineAlpha = 0;\n          let line2 = 0;\n\n          for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\n            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n            area[blueIndex] += line;\n            areaRed[blueIndex] += lineRed;\n            areaGreen[blueIndex] += lineGreen;\n            areaBlue[blueIndex] += lineBlue;\n            areaAlpha[blueIndex] += lineAlpha;\n            area2[blueIndex] += line2;\n            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];\n            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];\n            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];\n            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];\n            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];\n            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];\n            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];\n            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];\n            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];\n            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];\n          }\n        }\n      }\n    }\n  }\n\n  static _volumeFloat(cube, moment) {\n    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n  }\n\n  static _volume(cube, moment) {\n    return _WuQuant._volumeFloat(cube, moment) | 0;\n  }\n\n  static _top(cube, direction, position, moment) {\n    let result;\n\n    switch (direction) {\n      case _WuQuant._alpha:\n        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n        break;\n\n      case _WuQuant._red:\n        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);\n        break;\n\n      case _WuQuant._green:\n        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);\n        break;\n\n      case _WuQuant._blue:\n        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);\n        break;\n\n      default:\n        throw new Error(\"impossible\");\n    }\n\n    return result | 0;\n  }\n\n  static _bottom(cube, direction, moment) {\n    switch (direction) {\n      case _WuQuant._alpha:\n        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n\n      case _WuQuant._red:\n        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n\n      case _WuQuant._green:\n        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n\n      case _WuQuant._blue:\n        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);\n\n      default:\n        return 0;\n    }\n  }\n\n  _calculateVariance(cube) {\n    const volumeRed = _WuQuant._volume(cube, this._momentsRed);\n\n    const volumeGreen = _WuQuant._volume(cube, this._momentsGreen);\n\n    const volumeBlue = _WuQuant._volume(cube, this._momentsBlue);\n\n    const volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);\n\n    const volumeMoment = _WuQuant._volumeFloat(cube, this._moments);\n\n    const volumeWeight = _WuQuant._volume(cube, this._weights);\n\n    const distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\n    return volumeMoment - distance / volumeWeight;\n  }\n\n  _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {\n    const bottomRed = _WuQuant._bottom(cube, direction, this._momentsRed) | 0;\n    const bottomGreen = _WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\n    const bottomBlue = _WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\n    const bottomAlpha = _WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\n    const bottomWeight = _WuQuant._bottom(cube, direction, this._weights) | 0;\n    let result = 0;\n    let cutPosition = -1;\n\n    for (let position = first; position < last; ++position) {\n      let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed);\n\n      let halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen);\n\n      let halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue);\n\n      let halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha);\n\n      let halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);\n\n      if (halfWeight !== 0) {\n        let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n        let temp = halfDistance / halfWeight;\n        halfRed = wholeRed - halfRed;\n        halfGreen = wholeGreen - halfGreen;\n        halfBlue = wholeBlue - halfBlue;\n        halfAlpha = wholeAlpha - halfAlpha;\n        halfWeight = wholeWeight - halfWeight;\n\n        if (halfWeight !== 0) {\n          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\n          temp += halfDistance / halfWeight;\n\n          if (temp > result) {\n            result = temp;\n            cutPosition = position;\n          }\n        }\n      }\n    }\n\n    return {\n      max: result,\n      position: cutPosition\n    };\n  }\n\n  _cut(first, second) {\n    let direction;\n\n    const wholeRed = _WuQuant._volume(first, this._momentsRed);\n\n    const wholeGreen = _WuQuant._volume(first, this._momentsGreen);\n\n    const wholeBlue = _WuQuant._volume(first, this._momentsBlue);\n\n    const wholeAlpha = _WuQuant._volume(first, this._momentsAlpha);\n\n    const wholeWeight = _WuQuant._volume(first, this._weights);\n\n    const red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n\n    const green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n\n    const blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n\n    const alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\n\n    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\n      direction = _WuQuant._alpha;\n      if (alpha.position < 0) return false;\n    } else if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\n      direction = _WuQuant._red;\n    } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\n      direction = _WuQuant._green;\n    } else {\n      direction = _WuQuant._blue;\n    }\n\n    second.redMaximum = first.redMaximum;\n    second.greenMaximum = first.greenMaximum;\n    second.blueMaximum = first.blueMaximum;\n    second.alphaMaximum = first.alphaMaximum;\n\n    switch (direction) {\n      case _WuQuant._red:\n        second.redMinimum = first.redMaximum = red.position;\n        second.greenMinimum = first.greenMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case _WuQuant._green:\n        second.greenMinimum = first.greenMaximum = green.position;\n        second.redMinimum = first.redMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case _WuQuant._blue:\n        second.blueMinimum = first.blueMaximum = blue.position;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case _WuQuant._alpha:\n        second.alphaMinimum = first.alphaMaximum = alpha.position;\n        second.blueMinimum = first.blueMinimum;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        break;\n    }\n\n    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\n    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\n    return true;\n  }\n\n  _initialize(colors) {\n    this._colors = colors;\n    this._cubes = [];\n\n    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n      this._cubes[cubeIndex] = new WuColorCube();\n    }\n\n    this._cubes[0].redMinimum = 0;\n    this._cubes[0].greenMinimum = 0;\n    this._cubes[0].blueMinimum = 0;\n    this._cubes[0].alphaMinimum = 0;\n    this._cubes[0].redMaximum = this._maxSideIndex;\n    this._cubes[0].greenMaximum = this._maxSideIndex;\n    this._cubes[0].blueMaximum = this._maxSideIndex;\n    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\n    this._table = [];\n\n    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\n      this._table[tableIndex] = tableIndex * tableIndex;\n    }\n\n    this._pixels = [];\n  }\n\n  _setQuality() {\n    let significantBitsPerChannel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n    this._significantBitsPerChannel = significantBitsPerChannel;\n    this._maxSideIndex = 1 << this._significantBitsPerChannel;\n    this._alphaMaxSideIndex = this._maxSideIndex;\n    this._sideSize = this._maxSideIndex + 1;\n    this._alphaSideSize = this._alphaMaxSideIndex + 1;\n  }\n\n};\n\nvar WuQuant = _WuQuant;\n\n__publicField(WuQuant, \"_alpha\", 3);\n\n__publicField(WuQuant, \"_red\", 2);\n\n__publicField(WuQuant, \"_green\", 1);\n\n__publicField(WuQuant, \"_blue\", 0); // src/image/index.ts\n\n\nvar image_exports = {};\n\n__export(image_exports, {\n  AbstractImageQuantizer: () => AbstractImageQuantizer,\n  ErrorDiffusionArray: () => ErrorDiffusionArray,\n  ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,\n  ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,\n  NearestColor: () => NearestColor\n}); // src/image/imageQuantizer.ts\n\n\nvar AbstractImageQuantizer = class {\n  quantizeSync(pointContainer, palette) {\n    for (const value of this.quantize(pointContainer, palette)) {\n      if (value.pointContainer) {\n        return value.pointContainer;\n      }\n    }\n\n    throw new Error(\"unreachable\");\n  }\n\n}; // src/image/nearestColor.ts\n\nvar NearestColor = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator) {\n    super();\n\n    __publicField(this, \"_distance\");\n\n    this._distance = colorDistanceCalculator;\n  }\n\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const tracker = new ProgressTracker(height, 99);\n\n    for (let y2 = 0; y2 < height; y2++) {\n      if (tracker.shouldNotify(y2)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n\n      for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {\n        const point = pointArray[idx];\n        point.from(palette.getNearestColor(this._distance, point));\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n\n}; // src/image/array.ts\n\nvar ErrorDiffusionArrayKernel = /* @__PURE__ */(ErrorDiffusionArrayKernel2 => {\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"FloydSteinberg\"] = 0] = \"FloydSteinberg\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"FalseFloydSteinberg\"] = 1] = \"FalseFloydSteinberg\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Stucki\"] = 2] = \"Stucki\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Atkinson\"] = 3] = \"Atkinson\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Jarvis\"] = 4] = \"Jarvis\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Burkes\"] = 5] = \"Burkes\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"Sierra\"] = 6] = \"Sierra\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"TwoSierra\"] = 7] = \"TwoSierra\";\n  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2[\"SierraLite\"] = 8] = \"SierraLite\";\n  return ErrorDiffusionArrayKernel2;\n})(ErrorDiffusionArrayKernel || {});\n\nvar ErrorDiffusionArray = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator, kernel) {\n    let serpentine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let minimumColorDistanceToDither = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let calculateErrorLikeGIMP = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    super();\n\n    __publicField(this, \"_minColorDistance\");\n\n    __publicField(this, \"_serpentine\");\n\n    __publicField(this, \"_kernel\");\n\n    __publicField(this, \"_calculateErrorLikeGIMP\");\n\n    __publicField(this, \"_distance\");\n\n    this._setKernel(kernel);\n\n    this._distance = colorDistanceCalculator;\n    this._minColorDistance = minimumColorDistanceToDither;\n    this._serpentine = serpentine;\n    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n  }\n\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const originalPoint = new Point();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorLines = [];\n    let dir = 1;\n    let maxErrorLines = 1;\n\n    for (const kernel of this._kernel) {\n      const kernelErrorLines = kernel[2] + 1;\n      if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\n    }\n\n    for (let i = 0; i < maxErrorLines; i++) {\n      this._fillErrorLine(errorLines[i] = [], width);\n    }\n\n    const tracker = new ProgressTracker(height, 99);\n\n    for (let y2 = 0; y2 < height; y2++) {\n      if (tracker.shouldNotify(y2)) {\n        yield {\n          progress: tracker.progress\n        };\n      }\n\n      if (this._serpentine) dir *= -1;\n      const lni = y2 * width;\n      const xStart = dir === 1 ? 0 : width - 1;\n      const xEnd = dir === 1 ? width : -1;\n\n      this._fillErrorLine(errorLines[0], width);\n\n      errorLines.push(errorLines.shift());\n      const errorLine = errorLines[0];\n\n      for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {\n        const point = pointArray[idx];\n        const error = errorLine[x2];\n        originalPoint.from(point);\n        const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3]));\n        const palettePoint = palette.getNearestColor(this._distance, correctedPoint);\n        point.from(palettePoint);\n\n        if (this._minColorDistance) {\n          const dist = this._distance.calculateNormalized(originalPoint, palettePoint);\n\n          if (dist < this._minColorDistance) continue;\n        }\n\n        let er;\n        let eg;\n        let eb;\n        let ea;\n\n        if (this._calculateErrorLikeGIMP) {\n          er = correctedPoint.r - palettePoint.r;\n          eg = correctedPoint.g - palettePoint.g;\n          eb = correctedPoint.b - palettePoint.b;\n          ea = correctedPoint.a - palettePoint.a;\n        } else {\n          er = originalPoint.r - palettePoint.r;\n          eg = originalPoint.g - palettePoint.g;\n          eb = originalPoint.b - palettePoint.b;\n          ea = originalPoint.a - palettePoint.a;\n        }\n\n        const dStart = dir === 1 ? 0 : this._kernel.length - 1;\n        const dEnd = dir === 1 ? this._kernel.length : -1;\n\n        for (let i = dStart; i !== dEnd; i += dir) {\n          const x1 = this._kernel[i][1] * dir;\n          const y1 = this._kernel[i][2];\n\n          if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {\n            const d = this._kernel[i][0];\n            const e = errorLines[y1][x1 + x2];\n            e[0] += er * d;\n            e[1] += eg * d;\n            e[2] += eb * d;\n            e[3] += ea * d;\n          }\n        }\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n\n  _fillErrorLine(errorLine, width) {\n    if (errorLine.length > width) {\n      errorLine.length = width;\n    }\n\n    const l = errorLine.length;\n\n    for (let i = 0; i < l; i++) {\n      const error = errorLine[i];\n      error[0] = error[1] = error[2] = error[3] = 0;\n    }\n\n    for (let i = l; i < width; i++) {\n      errorLine[i] = [0, 0, 0, 0];\n    }\n  }\n\n  _setKernel(kernel) {\n    switch (kernel) {\n      case 0\n      /* FloydSteinberg */\n      :\n        this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];\n        break;\n\n      case 1\n      /* FalseFloydSteinberg */\n      :\n        this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];\n        break;\n\n      case 2\n      /* Stucki */\n      :\n        this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];\n        break;\n\n      case 3\n      /* Atkinson */\n      :\n        this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];\n        break;\n\n      case 4\n      /* Jarvis */\n      :\n        this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];\n        break;\n\n      case 5\n      /* Burkes */\n      :\n        this._kernel = [[8 / 32, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [8 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];\n        break;\n\n      case 6\n      /* Sierra */\n      :\n        this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];\n        break;\n\n      case 7\n      /* TwoSierra */\n      :\n        this._kernel = [[4 / 16, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];\n        break;\n\n      case 8\n      /* SierraLite */\n      :\n        this._kernel = [[2 / 4, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];\n        break;\n\n      default:\n        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);\n    }\n  }\n\n}; // src/image/spaceFillingCurves/hilbertCurve.ts\n\nfunction* hilbertCurve(width, height, callback) {\n  const maxBound = Math.max(width, height);\n  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\n  const tracker = new ProgressTracker(width * height, 99);\n  const data = {\n    width,\n    height,\n    level,\n    callback,\n    tracker,\n    index: 0,\n    x: 0,\n    y: 0\n  };\n  yield* walkHilbert(data, 1\n  /* UP */\n  );\n  visit(data, 0\n  /* NONE */\n  );\n}\n\nfunction* walkHilbert(data, direction) {\n  if (data.level < 1) return;\n\n  if (data.tracker.shouldNotify(data.index)) {\n    yield {\n      progress: data.tracker.progress\n    };\n  }\n\n  data.level--;\n\n  switch (direction) {\n    case 2\n    /* LEFT */\n    :\n      yield* walkHilbert(data, 1\n      /* UP */\n      );\n      visit(data, 3\n      /* RIGHT */\n      );\n      yield* walkHilbert(data, 2\n      /* LEFT */\n      );\n      visit(data, 4\n      /* DOWN */\n      );\n      yield* walkHilbert(data, 2\n      /* LEFT */\n      );\n      visit(data, 2\n      /* LEFT */\n      );\n      yield* walkHilbert(data, 4\n      /* DOWN */\n      );\n      break;\n\n    case 3\n    /* RIGHT */\n    :\n      yield* walkHilbert(data, 4\n      /* DOWN */\n      );\n      visit(data, 2\n      /* LEFT */\n      );\n      yield* walkHilbert(data, 3\n      /* RIGHT */\n      );\n      visit(data, 1\n      /* UP */\n      );\n      yield* walkHilbert(data, 3\n      /* RIGHT */\n      );\n      visit(data, 3\n      /* RIGHT */\n      );\n      yield* walkHilbert(data, 1\n      /* UP */\n      );\n      break;\n\n    case 1\n    /* UP */\n    :\n      yield* walkHilbert(data, 2\n      /* LEFT */\n      );\n      visit(data, 4\n      /* DOWN */\n      );\n      yield* walkHilbert(data, 1\n      /* UP */\n      );\n      visit(data, 3\n      /* RIGHT */\n      );\n      yield* walkHilbert(data, 1\n      /* UP */\n      );\n      visit(data, 1\n      /* UP */\n      );\n      yield* walkHilbert(data, 3\n      /* RIGHT */\n      );\n      break;\n\n    case 4\n    /* DOWN */\n    :\n      yield* walkHilbert(data, 3\n      /* RIGHT */\n      );\n      visit(data, 1\n      /* UP */\n      );\n      yield* walkHilbert(data, 4\n      /* DOWN */\n      );\n      visit(data, 2\n      /* LEFT */\n      );\n      yield* walkHilbert(data, 4\n      /* DOWN */\n      );\n      visit(data, 4\n      /* DOWN */\n      );\n      yield* walkHilbert(data, 2\n      /* LEFT */\n      );\n      break;\n\n    default:\n      break;\n  }\n\n  data.level++;\n}\n\nfunction visit(data, direction) {\n  if (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height) {\n    data.callback(data.x, data.y);\n    data.index++;\n  }\n\n  switch (direction) {\n    case 2\n    /* LEFT */\n    :\n      data.x--;\n      break;\n\n    case 3\n    /* RIGHT */\n    :\n      data.x++;\n      break;\n\n    case 1\n    /* UP */\n    :\n      data.y--;\n      break;\n\n    case 4\n    /* DOWN */\n    :\n      data.y++;\n      break;\n  }\n} // src/image/riemersma.ts\n\n\nvar ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {\n  constructor(colorDistanceCalculator) {\n    let errorQueueSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let errorPropagation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    super();\n\n    __publicField(this, \"_distance\");\n\n    __publicField(this, \"_weights\");\n\n    __publicField(this, \"_errorQueueSize\");\n\n    this._distance = colorDistanceCalculator;\n    this._errorQueueSize = errorQueueSize;\n    this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);\n  }\n\n  *quantize(pointContainer, palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorQueue = [];\n    let head = 0;\n\n    for (let i = 0; i < this._errorQueueSize; i++) {\n      errorQueue[i] = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 0\n      };\n    }\n\n    yield* hilbertCurve(width, height, (x2, y2) => {\n      const p = pointArray[x2 + y2 * width];\n      let {\n        r,\n        g,\n        b,\n        a\n      } = p;\n\n      for (let i = 0; i < this._errorQueueSize; i++) {\n        const weight = this._weights[i];\n        const e = errorQueue[(i + head) % this._errorQueueSize];\n        r += e.r * weight;\n        g += e.g * weight;\n        b += e.b * weight;\n        a += e.a * weight;\n      }\n\n      const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a));\n      const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);\n      head = (head + 1) % this._errorQueueSize;\n      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\n      errorQueue[tail].r = p.r - quantizedPoint.r;\n      errorQueue[tail].g = p.g - quantizedPoint.g;\n      errorQueue[tail].b = p.b - quantizedPoint.b;\n      errorQueue[tail].a = p.a - quantizedPoint.a;\n      p.from(quantizedPoint);\n    });\n    yield {\n      pointContainer,\n      progress: 100\n    };\n  }\n\n  static _createWeights(errorPropagation, errorQueueSize) {\n    const weights = [];\n    const multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));\n\n    for (let i = 0, next = 1; i < errorQueueSize; i++) {\n      weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation;\n      next *= multiplier;\n    }\n\n    return weights;\n  }\n\n}; // src/quality/index.ts\n\nvar quality_exports = {};\n\n__export(quality_exports, {\n  ssim: () => ssim\n}); // src/quality/ssim.ts\n\n\nvar K1 = 0.01;\nvar K2 = 0.03;\n\nfunction ssim(image1, image2) {\n  if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\n    throw new Error(\"Images have different sizes!\");\n  }\n\n  const bitsPerComponent = 8;\n  const L = (1 << bitsPerComponent) - 1;\n  const c1 = (K1 * L) ** 2;\n  const c2 = (K2 * L) ** 2;\n  let numWindows = 0;\n  let mssim = 0;\n  iterate(image1, image2, (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\n    let sigxy = 0;\n    let sigsqx = 0;\n    let sigsqy = 0;\n\n    for (let i = 0; i < lumaValues1.length; i++) {\n      sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;\n      sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;\n      sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);\n    }\n\n    const numPixelsInWin = lumaValues1.length - 1;\n    sigsqx /= numPixelsInWin;\n    sigsqy /= numPixelsInWin;\n    sigxy /= numPixelsInWin;\n    const numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n    const denominator = (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2);\n    const ssim2 = numerator / denominator;\n    mssim += ssim2;\n    numWindows++;\n  });\n  return mssim / numWindows;\n}\n\nfunction iterate(image1, image2, callback) {\n  const windowSize = 8;\n  const width = image1.getWidth();\n  const height = image1.getHeight();\n\n  for (let y2 = 0; y2 < height; y2 += windowSize) {\n    for (let x2 = 0; x2 < width; x2 += windowSize) {\n      const windowWidth = Math.min(windowSize, width - x2);\n      const windowHeight = Math.min(windowSize, height - y2);\n      const lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight);\n      const lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);\n      const averageLuma1 = calculateAverageLuma(lumaValues1);\n      const averageLuma2 = calculateAverageLuma(lumaValues2);\n      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n    }\n  }\n}\n\nfunction calculateLumaValuesForWindow(image, x2, y2, width, height) {\n  const pointArray = image.getPointArray();\n  const lumaValues = [];\n  let counter = 0;\n\n  for (let j = y2; j < y2 + height; j++) {\n    const offset = j * image.getWidth();\n\n    for (let i = x2; i < x2 + width; i++) {\n      const point = pointArray[offset + i];\n      lumaValues[counter] = point.r * 0.2126\n      /* RED */\n      + point.g * 0.7152\n      /* GREEN */\n      + point.b * 0.0722\n      /* BLUE */\n      ;\n      counter++;\n    }\n  }\n\n  return lumaValues;\n}\n\nfunction calculateAverageLuma(lumaValues) {\n  let sumLuma = 0;\n\n  for (const luma of lumaValues) {\n    sumLuma += luma;\n  }\n\n  return sumLuma / lumaValues.length;\n} // src/basicAPI.ts\n\n\nvar setImmediateImpl = typeof setImmediate === \"function\" ? setImmediate : typeof process !== \"undefined\" && typeof (process == null ? void 0 : process.nextTick) === \"function\" ? callback => process.nextTick(callback) : callback => setTimeout(callback, 0);\n\nfunction buildPaletteSync(images) {\n  let {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\n  images.forEach(image => paletteQuantizer.sample(image));\n  return paletteQuantizer.quantizeSync();\n}\n\nasync function buildPalette(images) {\n  let {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n    onProgress\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization, colors);\n    images.forEach(image => paletteQuantizer.sample(image));\n    let palette;\n    const iterator = paletteQuantizer.quantize();\n\n    const next = () => {\n      try {\n        const result = iterator.next();\n\n        if (result.done) {\n          resolve(palette);\n        } else {\n          if (result.value.palette) palette = result.value.palette;\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    setImmediateImpl(next);\n  });\n}\n\nfunction applyPaletteSync(image, palette) {\n  let {\n    colorDistanceFormula,\n    imageQuantization\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\n  return imageQuantizer.quantizeSync(image, palette);\n}\n\nasync function applyPalette(image, palette) {\n  let {\n    colorDistanceFormula,\n    imageQuantization,\n    onProgress\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return new Promise((resolve, reject) => {\n    const distanceCalculator = colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const imageQuantizer = imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization);\n    let outPointContainer;\n    const iterator = imageQuantizer.quantize(image, palette);\n\n    const next = () => {\n      try {\n        const result = iterator.next();\n\n        if (result.done) {\n          resolve(outPointContainer);\n        } else {\n          if (result.value.pointContainer) {\n            outPointContainer = result.value.pointContainer;\n          }\n\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    setImmediateImpl(next);\n  });\n}\n\nfunction colorDistanceFormulaToColorDistance() {\n  let colorDistanceFormula = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"euclidean-bt709\";\n\n  switch (colorDistanceFormula) {\n    case \"cie94-graphic-arts\":\n      return new CIE94GraphicArts();\n\n    case \"cie94-textiles\":\n      return new CIE94Textiles();\n\n    case \"ciede2000\":\n      return new CIEDE2000();\n\n    case \"color-metric\":\n      return new CMetric();\n\n    case \"euclidean\":\n      return new Euclidean();\n\n    case \"euclidean-bt709\":\n      return new EuclideanBT709();\n\n    case \"euclidean-bt709-noalpha\":\n      return new EuclideanBT709NoAlpha();\n\n    case \"manhattan\":\n      return new Manhattan();\n\n    case \"manhattan-bt709\":\n      return new ManhattanBT709();\n\n    case \"manhattan-nommyde\":\n      return new ManhattanNommyde();\n\n    case \"pngquant\":\n      return new PNGQuant();\n\n    default:\n      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\n  }\n}\n\nfunction imageQuantizationToImageQuantizer(distanceCalculator) {\n  let imageQuantization = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"floyd-steinberg\";\n\n  switch (imageQuantization) {\n    case \"nearest\":\n      return new NearestColor(distanceCalculator);\n\n    case \"riemersma\":\n      return new ErrorDiffusionRiemersma(distanceCalculator);\n\n    case \"floyd-steinberg\":\n      return new ErrorDiffusionArray(distanceCalculator, 0\n      /* FloydSteinberg */\n      );\n\n    case \"false-floyd-steinberg\":\n      return new ErrorDiffusionArray(distanceCalculator, 1\n      /* FalseFloydSteinberg */\n      );\n\n    case \"stucki\":\n      return new ErrorDiffusionArray(distanceCalculator, 2\n      /* Stucki */\n      );\n\n    case \"atkinson\":\n      return new ErrorDiffusionArray(distanceCalculator, 3\n      /* Atkinson */\n      );\n\n    case \"jarvis\":\n      return new ErrorDiffusionArray(distanceCalculator, 4\n      /* Jarvis */\n      );\n\n    case \"burkes\":\n      return new ErrorDiffusionArray(distanceCalculator, 5\n      /* Burkes */\n      );\n\n    case \"sierra\":\n      return new ErrorDiffusionArray(distanceCalculator, 6\n      /* Sierra */\n      );\n\n    case \"two-sierra\":\n      return new ErrorDiffusionArray(distanceCalculator, 7\n      /* TwoSierra */\n      );\n\n    case \"sierra-lite\":\n      return new ErrorDiffusionArray(distanceCalculator, 8\n      /* SierraLite */\n      );\n\n    default:\n      throw new Error(`Unknown imageQuantization ${imageQuantization}`);\n  }\n}\n\nfunction paletteQuantizationToPaletteQuantizer(distanceCalculator) {\n  let paletteQuantization = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"wuquant\";\n  let colors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 256;\n\n  switch (paletteQuantization) {\n    case \"neuquant\":\n      return new NeuQuant(distanceCalculator, colors);\n\n    case \"rgbquant\":\n      return new RGBQuant(distanceCalculator, colors);\n\n    case \"wuquant\":\n      return new WuQuant(distanceCalculator, colors);\n\n    case \"neuquant-float\":\n      return new NeuQuantFloat(distanceCalculator, colors);\n\n    default:\n      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\n  }\n}\n\nexport { applyPalette, applyPaletteSync, buildPalette, buildPaletteSync, constants_exports as constants, conversion_exports as conversion, distance_exports as distance, image_exports as image, palette_exports as palette, quality_exports as quality, utils_exports as utils };\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cie94.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ciede2000.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cmetric.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * euclidean.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * helper.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * hueStatistics.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2rgb.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2xyz.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * manhattanNeuQuant.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * nearestColor.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pngQuant.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * point.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pointContainer.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2hsl.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2lab.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2xyz.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * wuQuant.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2lab.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2rgb.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve\n * MIT License\n *\n * Copyright 2015-2018 Igor Bezkrovnyi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * riemersma.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgbquant.ts - part of Image Quantization Library\n */","map":{"version":3,"sources":["../../src/constants/index.ts","../../src/constants/bt709.ts","../../src/conversion/index.ts","../../src/conversion/rgb2xyz.ts","../../src/utils/arithmetic.ts","../../src/conversion/rgb2hsl.ts","../../src/conversion/xyz2lab.ts","../../src/conversion/rgb2lab.ts","../../src/conversion/lab2xyz.ts","../../src/conversion/xyz2rgb.ts","../../src/conversion/lab2rgb.ts","../../src/distance/index.ts","../../src/distance/distanceCalculator.ts","../../src/distance/cie94.ts","../../src/distance/ciede2000.ts","../../src/distance/cmetric.ts","../../src/distance/euclidean.ts","../../src/distance/manhattan.ts","../../src/distance/pngQuant.ts","../../src/palette/index.ts","../../src/palette/paletteQuantizer.ts","../../src/utils/point.ts","../../src/utils/pointContainer.ts","../../src/utils/palette.ts","../../src/utils/index.ts","../../src/utils/hueStatistics.ts","../../src/utils/progressTracker.ts","../../src/palette/neuquant/neuquant.ts","../../src/palette/neuquant/neuquantFloat.ts","../../src/palette/rgbquant/colorHistogram.ts","../../src/palette/rgbquant/rgbquant.ts","../../src/palette/wu/wuQuant.ts","../../src/image/index.ts","../../src/image/imageQuantizer.ts","../../src/image/nearestColor.ts","../../src/image/array.ts","../../src/image/spaceFillingCurves/hilbertCurve.ts","../../src/image/riemersma.ts","../../src/quality/index.ts","../../src/quality/ssim.ts","../../src/basicAPI.ts","../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\nimport * as bt709 from './bt709';\n\nexport { bt709 };\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * constants.ts - part of Image Quantization Library\n */\n\n/**\n * sRGB (based on ITU-R Recommendation BT.709)\n * http://en.wikipedia.org/wiki/SRGB\n */\nexport enum Y {\n  RED = 0.2126,\n  GREEN = 0.7152,\n  BLUE = 0.0722,\n  WHITE = 1,\n}\n\nexport enum x {\n  RED = 0.64,\n  GREEN = 0.3,\n  BLUE = 0.15,\n  WHITE = 0.3127,\n}\n\nexport enum y {\n  RED = 0.33,\n  GREEN = 0.6,\n  BLUE = 0.06,\n  WHITE = 0.329,\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { rgb2xyz } from './rgb2xyz';\nexport { rgb2hsl } from './rgb2hsl';\nexport { rgb2lab } from './rgb2lab';\nexport { lab2xyz } from './lab2xyz';\nexport { lab2rgb } from './lab2rgb';\nexport { xyz2lab } from './xyz2lab';\nexport { xyz2rgb } from './xyz2rgb';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2xyz.ts - part of Image Quantization Library\n */\nfunction correctGamma(n: number) {\n  return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;\n}\n\nexport function rgb2xyz(r: number, g: number, b: number) {\n  // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\n  r = correctGamma(r / 255);\n  g = correctGamma(g / 255);\n  b = correctGamma(b / 255);\n\n  // Observer. = 2°, Illuminant = D65\n  return {\n    x: r * 0.4124 + g * 0.3576 + b * 0.1805,\n    y: r * 0.2126 + g * 0.7152 + b * 0.0722,\n    z: r * 0.0193 + g * 0.1192 + b * 0.9505,\n  };\n}\n","export function degrees2radians(n: number) {\n  return n * (Math.PI / 180);\n}\n\nexport function max3(a: number, b: number, c: number) {\n  let m = a;\n  if (m < b) m = b;\n  if (m < c) m = c;\n  return m;\n}\n\nexport function min3(a: number, b: number, c: number) {\n  let m = a;\n  if (m > b) m = b;\n  if (m > c) m = c;\n  return m;\n}\n\nexport function intInRange(value: number, low: number, high: number) {\n  if (value > high) value = high;\n  if (value < low) value = low;\n  return value | 0;\n}\n\nexport function inRange0to255Rounded(n: number) {\n  n = Math.round(n);\n  if (n > 255) n = 255;\n  else if (n < 0) n = 0;\n  return n;\n}\n\nexport function inRange0to255(n: number) {\n  if (n > 255) n = 255;\n  else if (n < 0) n = 0;\n  return n;\n}\n\nexport function stableSort<T>(\n  arrayToSort: T[],\n  callback: (a: T, b: T) => number,\n) {\n  const type = typeof arrayToSort[0];\n  let sorted: T[];\n\n  if (type === 'number' || type === 'string') {\n    const ord = Object.create(null);\n    for (let i = 0, l = arrayToSort.length; i < l; i++) {\n      const val = arrayToSort[i] as unknown as string;\n      if (ord[val] || ord[val] === 0) continue;\n      ord[val] = i;\n    }\n\n    sorted = arrayToSort.sort((a, b) => callback(a, b) || ord[a] - ord[b]);\n  } else {\n    const ord2 = arrayToSort.slice(0);\n    sorted = arrayToSort.sort(\n      (a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b),\n    );\n  }\n\n  return sorted;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2hsl.ts - part of Image Quantization Library\n */\nimport { min3, max3 } from '../utils/arithmetic';\n\n/**\n * Calculate HSL from RGB\n * Hue is in degrees [0..360]\n * Lightness: [0..1]\n * Saturation: [0..1]\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\n */\nexport function rgb2hsl(r: number, g: number, b: number) {\n  const min = min3(r, g, b);\n  const max = max3(r, g, b);\n  const delta = max - min;\n  const l = (min + max) / 510;\n\n  let s = 0;\n  if (l > 0 && l < 1) s = delta / (l < 0.5 ? max + min : 510 - max - min);\n\n  let h = 0;\n  if (delta > 0) {\n    if (max === r) {\n      h = (g - b) / delta;\n    } else if (max === g) {\n      h = 2 + (b - r) / delta;\n    } else {\n      h = 4 + (r - g) / delta;\n    }\n\n    h *= 60;\n    if (h < 0) h += 360;\n  }\n  return { h, s, l };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2lab.ts - part of Image Quantization Library\n */\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2°, Illuminant= D65\nconst refY = 1.0; // ref_Y = 100.000\nconst refZ = 1.08883; // ref_Z = 108.883\n\nfunction pivot(n: number) {\n  return n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116;\n}\n\nexport function xyz2lab(x: number, y: number, z: number) {\n  x = pivot(x / refX);\n  y = pivot(y / refY);\n  z = pivot(z / refZ);\n\n  if (116 * y - 16 < 0) throw new Error('xxx');\n  return {\n    L: Math.max(0, 116 * y - 16),\n    a: 500 * (x - y),\n    b: 200 * (y - z),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgb2lab.ts - part of Image Quantization Library\n */\nimport { rgb2xyz } from './rgb2xyz';\nimport { xyz2lab } from './xyz2lab';\n\nexport function rgb2lab(r: number, g: number, b: number) {\n  const xyz = rgb2xyz(r, g, b);\n  return xyz2lab(xyz.x, xyz.y, xyz.z);\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2xyz.ts - part of Image Quantization Library\n */\nconst refX = 0.95047; // ref_X =  95.047   Observer= 2°, Illuminant = D65\nconst refY = 1.0; // ref_Y = 100.000\nconst refZ = 1.08883; // ref_Z = 108.883\n\nfunction pivot(n: number) {\n  return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;\n}\n\nexport function lab2xyz(L: number, a: number, b: number) {\n  const y = (L + 16) / 116;\n  const x = a / 500 + y;\n  const z = y - b / 200;\n\n  return {\n    x: refX * pivot(x),\n    y: refY * pivot(y),\n    z: refZ * pivot(z),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * xyz2rgb.ts - part of Image Quantization Library\n */\nimport { inRange0to255Rounded } from '../utils/arithmetic';\n\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\nfunction correctGamma(n: number) {\n  return n > 0.0031308 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;\n}\n\nexport function xyz2rgb(x: number, y: number, z: number) {\n  // Observer. = 2°, Illuminant = D65\n  const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986);\n  const g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415);\n  const b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);\n\n  return {\n    r: inRange0to255Rounded(r * 255),\n    g: inRange0to255Rounded(g * 255),\n    b: inRange0to255Rounded(b * 255),\n  };\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * lab2rgb.ts - part of Image Quantization Library\n */\nimport { lab2xyz } from './lab2xyz';\nimport { xyz2rgb } from './xyz2rgb';\n\nexport function lab2rgb(L: number, a: number, b: number) {\n  const xyz = lab2xyz(L, a, b);\n  return xyz2rgb(xyz.x, xyz.y, xyz.z);\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { AbstractDistanceCalculator } from './distanceCalculator';\nexport { CIE94Textiles, CIE94GraphicArts } from './cie94';\nexport { CIEDE2000 } from './ciede2000';\nexport { CMetric } from './cmetric';\nexport {\n  AbstractEuclidean,\n  Euclidean,\n  EuclideanBT709NoAlpha,\n  EuclideanBT709,\n} from './euclidean';\nexport {\n  AbstractManhattan,\n  Manhattan,\n  ManhattanBT709,\n  ManhattanNommyde,\n} from './manhattan';\nexport { PNGQuant } from './pngQuant';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointRGBA } from '../utils/point';\n\nexport abstract class AbstractDistanceCalculator {\n  protected _maxDistance!: number;\n  protected _whitePoint!: {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n  };\n\n  constructor() {\n    this._setDefaults();\n\n    // set default maximal color component deltas (255 - 0 = 255)\n    this.setWhitePoint(255, 255, 255, 255);\n  }\n\n  setWhitePoint(r: number, g: number, b: number, a: number) {\n    this._whitePoint = {\n      r: r > 0 ? 255 / r : 0,\n      g: g > 0 ? 255 / g : 0,\n      b: b > 0 ? 255 / b : 0,\n      a: a > 0 ? 255 / a : 0,\n    };\n    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\n  }\n\n  calculateNormalized(colorA: PointRGBA, colorB: PointRGBA) {\n    return (\n      this.calculateRaw(\n        colorA.r,\n        colorA.g,\n        colorA.b,\n        colorA.a,\n        colorB.r,\n        colorB.g,\n        colorB.b,\n        colorB.a,\n      ) / this._maxDistance\n    );\n  }\n\n  /**\n   * Calculate raw distance (non-normalized)\n   */\n  abstract calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ): number;\n\n  protected abstract _setDefaults(): void;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cie94.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { rgb2lab } from '../conversion/rgb2lab';\nimport { inRange0to255 } from '../utils/arithmetic';\n\n/**\n * CIE94 method of delta-e\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\n */\nexport abstract class AbstractCIE94 extends AbstractDistanceCalculator {\n  /**\n   * Weight in distance: 0.25\n   * Max DeltaE: 100\n   * Max DeltaA: 255\n   */\n  declare protected _kA: number;\n  declare protected _Kl: number;\n  declare protected _K1: number;\n  declare protected _K2: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const lab1 = rgb2lab(\n      inRange0to255(r1 * this._whitePoint.r),\n      inRange0to255(g1 * this._whitePoint.g),\n      inRange0to255(b1 * this._whitePoint.b),\n    );\n    const lab2 = rgb2lab(\n      inRange0to255(r2 * this._whitePoint.r),\n      inRange0to255(g2 * this._whitePoint.g),\n      inRange0to255(b2 * this._whitePoint.b),\n    );\n\n    const dL = lab1.L - lab2.L;\n    const dA = lab1.a - lab2.a;\n    const dB = lab1.b - lab2.b;\n    const c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b);\n    const c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);\n    const dC = c1 - c2;\n\n    let deltaH = dA * dA + dB * dB - dC * dC;\n    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);\n\n    const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\n\n    // TODO: add alpha channel support\n    return Math.sqrt(\n      (dL / this._Kl) ** 2 +\n        (dC / (1.0 + this._K1 * c1)) ** 2 +\n        (deltaH / (1.0 + this._K2 * c1)) ** 2 +\n        dAlpha ** 2,\n    );\n  }\n}\n\nexport class CIE94Textiles extends AbstractCIE94 {\n  protected _setDefaults() {\n    this._Kl = 2.0;\n    this._K1 = 0.048;\n    this._K2 = 0.014;\n    this._kA = (0.25 * 50) / 255;\n  }\n}\n\nexport class CIE94GraphicArts extends AbstractCIE94 {\n  protected _setDefaults() {\n    this._Kl = 1.0;\n    this._K1 = 0.045;\n    this._K2 = 0.015;\n    this._kA = (0.25 * 100) / 255;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ciede2000.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { rgb2lab } from '../conversion/rgb2lab';\nimport { degrees2radians, inRange0to255 } from '../utils/arithmetic';\n\n/**\n * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\n */\nexport class CIEDE2000 extends AbstractDistanceCalculator {\n  /**\n   * Weight in distance: 0.25\n   * Max DeltaE: 100\n   * Max DeltaA: 255\n   */\n  private static readonly _kA = (0.25 * 100) / 255;\n  private static readonly _pow25to7 = 25 ** 7;\n  private static readonly _deg360InRad = degrees2radians(360);\n  private static readonly _deg180InRad = degrees2radians(180);\n  private static readonly _deg30InRad = degrees2radians(30);\n  private static readonly _deg6InRad = degrees2radians(6);\n  private static readonly _deg63InRad = degrees2radians(63);\n  private static readonly _deg275InRad = degrees2radians(275);\n  private static readonly _deg25InRad = degrees2radians(25);\n\n  protected _setDefaults() {}\n\n  private static _calculatehp(b: number, ap: number) {\n    const hp = Math.atan2(b, ap);\n    if (hp >= 0) return hp;\n    return hp + CIEDE2000._deg360InRad;\n  }\n\n  private static _calculateRT(ahp: number, aCp: number) {\n    const aCp_to_7 = aCp ** 7.0;\n    const R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)); // 25^7\n    const delta_theta =\n      CIEDE2000._deg30InRad *\n      Math.exp(\n        -(((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad) ** 2.0),\n      );\n    return -Math.sin(2.0 * delta_theta) * R_C;\n  }\n\n  private static _calculateT(ahp: number) {\n    return (\n      1.0 -\n      0.17 * Math.cos(ahp - CIEDE2000._deg30InRad) +\n      0.24 * Math.cos(ahp * 2.0) +\n      0.32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) -\n      0.2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad)\n    );\n  }\n\n  private static _calculate_ahp(\n    C1pC2p: number,\n    h_bar: number,\n    h1p: number,\n    h2p: number,\n  ) {\n    const hpSum = h1p + h2p;\n    if (C1pC2p === 0) return hpSum;\n    if (h_bar <= CIEDE2000._deg180InRad) return hpSum / 2.0;\n    if (hpSum < CIEDE2000._deg360InRad) {\n      return (hpSum + CIEDE2000._deg360InRad) / 2.0;\n    }\n    return (hpSum - CIEDE2000._deg360InRad) / 2.0;\n  }\n\n  private static _calculate_dHp(\n    C1pC2p: number,\n    h_bar: number,\n    h2p: number,\n    h1p: number,\n  ) {\n    let dhp;\n    if (C1pC2p === 0) {\n      dhp = 0;\n    } else if (h_bar <= CIEDE2000._deg180InRad) {\n      dhp = h2p - h1p;\n    } else if (h2p <= h1p) {\n      dhp = h2p - h1p + CIEDE2000._deg360InRad;\n    } else {\n      dhp = h2p - h1p - CIEDE2000._deg360InRad;\n    }\n    return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\n  }\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const lab1 = rgb2lab(\n      inRange0to255(r1 * this._whitePoint.r),\n      inRange0to255(g1 * this._whitePoint.g),\n      inRange0to255(b1 * this._whitePoint.b),\n    );\n    const lab2 = rgb2lab(\n      inRange0to255(r2 * this._whitePoint.r),\n      inRange0to255(g2 * this._whitePoint.g),\n      inRange0to255(b2 * this._whitePoint.b),\n    );\n    const dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA;\n    const dE2 = this.calculateRawInLab(lab1, lab2);\n\n    return Math.sqrt(dE2 + dA * dA);\n  }\n\n  calculateRawInLab(\n    Lab1: { L: number; a: number; b: number },\n    Lab2: { L: number; a: number; b: number },\n  ) {\n    // Get L,a,b values for color 1\n    const L1 = Lab1.L;\n    const a1 = Lab1.a;\n    const b1 = Lab1.b;\n\n    // Get L,a,b values for color 2\n    const L2 = Lab2.L;\n    const a2 = Lab2.a;\n    const b2 = Lab2.b;\n\n    // Calculate Cprime1, Cprime2, Cabbar\n    const C1 = Math.sqrt(a1 * a1 + b1 * b1);\n    const C2 = Math.sqrt(a2 * a2 + b2 * b2);\n    const pow_a_C1_C2_to_7 = ((C1 + C2) / 2.0) ** 7.0;\n\n    const G =\n      0.5 *\n      (1.0 -\n        Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))); // 25^7\n    const a1p = (1.0 + G) * a1;\n    const a2p = (1.0 + G) * a2;\n\n    const C1p = Math.sqrt(a1p * a1p + b1 * b1);\n    const C2p = Math.sqrt(a2p * a2p + b2 * b2);\n    const C1pC2p = C1p * C2p;\n\n    // Angles in Degree.\n    const h1p = CIEDE2000._calculatehp(b1, a1p);\n    const h2p = CIEDE2000._calculatehp(b2, a2p);\n    const h_bar = Math.abs(h1p - h2p);\n    const dLp = L2 - L1;\n    const dCp = C2p - C1p;\n    const dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p);\n    const ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p);\n\n    const T = CIEDE2000._calculateT(ahp);\n\n    const aCp = (C1p + C2p) / 2.0;\n    const aLp_minus_50_square = ((L1 + L2) / 2.0 - 50.0) ** 2.0;\n    const S_L =\n      1.0 +\n      (0.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square);\n    const S_C = 1.0 + 0.045 * aCp;\n    const S_H = 1.0 + 0.015 * T * aCp;\n\n    const R_T = CIEDE2000._calculateRT(ahp, aCp);\n\n    const dLpSL = dLp / S_L; // S_L * kL, where kL is 1.0\n    const dCpSC = dCp / S_C; // S_C * kC, where kC is 1.0\n    const dHpSH = dHp / S_H; // S_H * kH, where kH is 1.0\n\n    return dLpSL ** 2 + dCpSC ** 2 + dHpSH ** 2 + R_T * dCpSC * dHpSH;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * cmetric.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\n\n/**\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\n */\nexport class CMetric extends AbstractDistanceCalculator {\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const rmean = ((r1 + r2) / 2) * this._whitePoint.r;\n    const r = (r1 - r2) * this._whitePoint.r;\n    const g = (g1 - g2) * this._whitePoint.g;\n    const b = (b1 - b2) * this._whitePoint.b;\n    const dE =\n      (((512 + rmean) * r * r) >> 8) +\n      4 * g * g +\n      (((767 - rmean) * b * b) >> 8);\n    const dA = (a2 - a1) * this._whitePoint.a;\n\n    return Math.sqrt(dE + dA * dA);\n  }\n\n  protected _setDefaults() {}\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * euclidean.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { Y } from '../constants/bt709';\n\n/**\n * Euclidean color distance\n */\nexport abstract class AbstractEuclidean extends AbstractDistanceCalculator {\n  declare protected _kR: number;\n  declare protected _kG: number;\n  declare protected _kB: number;\n  declare protected _kA: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const dR = r2 - r1;\n    const dG = g2 - g1;\n    const dB = b2 - b1;\n    const dA = a2 - a1;\n    return Math.sqrt(\n      this._kR * dR * dR +\n        this._kG * dG * dG +\n        this._kB * dB * dB +\n        this._kA * dA * dA,\n    );\n  }\n}\n\nexport class Euclidean extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n}\n\n/**\n * Euclidean color distance (RGBQuant modification w Alpha)\n */\nexport class EuclideanBT709 extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n\n/**\n * Euclidean color distance (RGBQuant modification w/o Alpha)\n */\nexport class EuclideanBT709NoAlpha extends AbstractEuclidean {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    this._kA = 0;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * manhattanNeuQuant.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\nimport { Y } from '../constants/bt709';\n\n/**\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\n */\nexport abstract class AbstractManhattan extends AbstractDistanceCalculator {\n  declare protected _kR: number;\n  declare  protected _kG: number;\n  declare protected _kB: number;\n  declare protected _kA: number;\n\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    let dR = r2 - r1;\n    let dG = g2 - g1;\n    let dB = b2 - b1;\n    let dA = a2 - a1;\n    if (dR < 0) dR = 0 - dR;\n    if (dG < 0) dG = 0 - dG;\n    if (dB < 0) dB = 0 - dB;\n    if (dA < 0) dA = 0 - dA;\n\n    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\n  }\n}\n\nexport class Manhattan extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = 1;\n    this._kG = 1;\n    this._kB = 1;\n    this._kA = 1;\n  }\n}\n\n/**\n * Manhattan distance (Nommyde modification)\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\n */\nexport class ManhattanNommyde extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = 0.4984;\n    this._kG = 0.8625;\n    this._kB = 0.2979;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n\n/**\n * Manhattan distance (sRGB coefficients)\n */\nexport class ManhattanBT709 extends AbstractManhattan {\n  protected _setDefaults() {\n    this._kR = Y.RED;\n    this._kG = Y.GREEN;\n    this._kB = Y.BLUE;\n    // TODO: what is the best coefficient below?\n    this._kA = 1;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pngQuant.ts - part of Image Quantization Library\n */\nimport { AbstractDistanceCalculator } from './distanceCalculator';\n\n/**\n * TODO: check quality of this distance equation\n * TODO: ask author for usage rights\n * taken from:\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\n */\nexport class PNGQuant extends AbstractDistanceCalculator {\n  /**\n   * Author's comments\n   * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\n   * px_b.a   = px.a   + 1*(1-px.a)\n   * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\n   * px_w.a   = px.a   + 1*(1-px.a)\n   *\n   * px_b.rgb = px.rgb              // difference same as in opaque RGB\n   * px_b.a   = 1\n   * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\n   * px_w.a   = 1\n   *\n   * (px.rgb - px.a) - (py.rgb - py.a)\n   * (px.rgb - py.rgb) + (py.a - px.a)\n   *\n   */\n  calculateRaw(\n    r1: number,\n    g1: number,\n    b1: number,\n    a1: number,\n    r2: number,\n    g2: number,\n    b2: number,\n    a2: number,\n  ) {\n    const alphas = (a2 - a1) * this._whitePoint.a;\n    return (\n      this._colordifferenceCh(\n        r1 * this._whitePoint.r,\n        r2 * this._whitePoint.r,\n        alphas,\n      ) +\n      this._colordifferenceCh(\n        g1 * this._whitePoint.g,\n        g2 * this._whitePoint.g,\n        alphas,\n      ) +\n      this._colordifferenceCh(\n        b1 * this._whitePoint.b,\n        b2 * this._whitePoint.b,\n        alphas,\n      )\n    );\n  }\n\n  private _colordifferenceCh(x: number, y: number, alphas: number) {\n    // maximum of channel blended on white, and blended on black\n    // premultiplied alpha and backgrounds 0/1 shorten the formula\n    const black = x - y;\n    const white = black + alphas;\n\n    return black * black + white * white;\n  }\n\n  protected _setDefaults() {}\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { AbstractPaletteQuantizer } from './paletteQuantizer';\nexport { NeuQuant } from './neuquant/neuquant';\nexport { NeuQuantFloat } from './neuquant/neuquantFloat';\nexport { RGBQuant } from './rgbquant/rgbquant';\nexport { ColorHistogram } from './rgbquant/colorHistogram';\nexport { WuQuant, WuColorCube } from './wu/wuQuant';\nexport { PaletteQuantizerYieldValue } from './paletteQuantizerYieldValue';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { PaletteQuantizerYieldValue } from './paletteQuantizerYieldValue';\n\nexport abstract class AbstractPaletteQuantizer {\n  abstract sample(pointContainer: PointContainer): void;\n  abstract quantize(): IterableIterator<PaletteQuantizerYieldValue>;\n\n  quantizeSync() {\n    for (const value of this.quantize()) {\n      if (value.palette) {\n        return value.palette;\n      }\n    }\n\n    throw new Error('unreachable');\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * point.ts - part of Image Quantization Library\n */\nimport { Y } from '../constants/bt709';\n\nexport interface PointRGBA {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\n/**\n * v8 optimized class\n * 1) \"constructor\" should have initialization with worst types\n * 2) \"set\" should have |0 / >>> 0\n */\nexport class Point implements PointRGBA {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n  uint32: number;\n  rgba: number[]; // TODO: better name is quadruplet or quad may be?\n  // Lab : { L : number; a : number; b : number };\n\n  static createByQuadruplet(quadruplet: number[]) {\n    const point = new Point();\n\n    point.r = quadruplet[0] | 0;\n    point.g = quadruplet[1] | 0;\n    point.b = quadruplet[2] | 0;\n    point.a = quadruplet[3] | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  static createByRGBA(red: number, green: number, blue: number, alpha: number) {\n    const point = new Point();\n\n    point.r = red | 0;\n    point.g = green | 0;\n    point.b = blue | 0;\n    point.a = alpha | 0;\n    point._loadUINT32();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  static createByUint32(uint32: number) {\n    const point = new Point();\n\n    point.uint32 = uint32 >>> 0;\n    point._loadRGBA();\n    point._loadQuadruplet();\n    // point._loadLab();\n    return point;\n  }\n\n  constructor() {\n    this.uint32 = -1 >>> 0;\n    this.r = this.g = this.b = this.a = 0;\n    this.rgba = new Array(4);\n    this.rgba[0] = 0;\n    this.rgba[1] = 0;\n    this.rgba[2] = 0;\n    this.rgba[3] = 0;\n    /*\n     this.Lab = {\n     L : 0.0,\n     a : 0.0,\n     b : 0.0\n     };\n     */\n  }\n\n  from(point: Point) {\n    this.r = point.r;\n    this.g = point.g;\n    this.b = point.b;\n    this.a = point.a;\n    this.uint32 = point.uint32;\n    this.rgba[0] = point.r;\n    this.rgba[1] = point.g;\n    this.rgba[2] = point.b;\n    this.rgba[3] = point.a;\n\n    /*\n     this.Lab.L = point.Lab.L;\n     this.Lab.a = point.Lab.a;\n     this.Lab.b = point.Lab.b;\n     */\n  }\n\n  /*\n   * TODO:\n   Luminance from RGB:\n\n   Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\n   Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\n   Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\n   */\n  getLuminosity(useAlphaChannel: boolean) {\n    let r = this.r;\n    let g = this.g;\n    let b = this.b;\n\n    if (useAlphaChannel) {\n      r = Math.min(255, 255 - this.a + (this.a * r) / 255);\n      g = Math.min(255, 255 - this.a + (this.a * g) / 255);\n      b = Math.min(255, 255 - this.a + (this.a * b) / 255);\n    }\n\n    // var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\n\n    /*\n     if(useAlphaChannel) {\n     luma = (luma * (255 - this.a)) / 255;\n     }\n     */\n\n    return r * Y.RED + g * Y.GREEN + b * Y.BLUE;\n  }\n\n  private _loadUINT32() {\n    this.uint32 =\n      ((this.a << 24) | (this.b << 16) | (this.g << 8) | this.r) >>> 0;\n  }\n\n  private _loadRGBA() {\n    this.r = this.uint32 & 0xff;\n    this.g = (this.uint32 >>> 8) & 0xff;\n    this.b = (this.uint32 >>> 16) & 0xff;\n    this.a = (this.uint32 >>> 24) & 0xff;\n  }\n\n  private _loadQuadruplet() {\n    this.rgba[0] = this.r;\n    this.rgba[1] = this.g;\n    this.rgba[2] = this.b;\n    this.rgba[3] = this.a;\n\n    /*\n     var xyz = rgb2xyz(this.r, this.g, this.b);\n     var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\n     this.lab.l = lab.l;\n     this.lab.a = lab.a;\n     this.lab.b = lab.b;\n     */\n  }\n\n  /*\n   private _loadLab() : void {\n   var Lab = Color.Conversion.rgb2lab(this.r, this.g, this.b);\n   this.Lab.L = Lab.L;\n   this.Lab.a = Lab.a;\n   this.Lab.b = Lab.b;\n   }\n   */\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * pointContainer.ts - part of Image Quantization Library\n */\nimport { Point } from './point';\n\n/**\n * v8 optimizations done.\n * fromXXX methods are static to move out polymorphic code from class instance itself.\n */\nexport class PointContainer {\n  private readonly _pointArray: Point[];\n  private _width: number;\n  private _height: number;\n\n  constructor() {\n    this._width = 0;\n    this._height = 0;\n    this._pointArray = [];\n  }\n\n  getWidth() {\n    return this._width;\n  }\n\n  getHeight() {\n    return this._height;\n  }\n\n  setWidth(width: number) {\n    this._width = width;\n  }\n\n  setHeight(height: number) {\n    this._height = height;\n  }\n\n  getPointArray() {\n    return this._pointArray;\n  }\n\n  clone() {\n    const clone = new PointContainer();\n    clone._width = this._width;\n    clone._height = this._height;\n\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      clone._pointArray[i] = Point.createByUint32(\n        this._pointArray[i].uint32 | 0,\n      ); // \"| 0\" is added for v8 optimization\n    }\n\n    return clone;\n  }\n\n  toUint32Array() {\n    const l = this._pointArray.length;\n    const uint32Array = new Uint32Array(l);\n\n    for (let i = 0; i < l; i++) {\n      uint32Array[i] = this._pointArray[i].uint32;\n    }\n\n    return uint32Array;\n  }\n\n  toUint8Array() {\n    return new Uint8Array(this.toUint32Array().buffer);\n  }\n\n  static fromHTMLImageElement(img: HTMLImageElement) {\n    const width = img.naturalWidth;\n    const height = img.naturalHeight;\n\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext('2d')!;\n    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\n\n    return PointContainer.fromHTMLCanvasElement(canvas);\n  }\n\n  static fromHTMLCanvasElement(canvas: HTMLCanvasElement) {\n    const width = canvas.width;\n    const height = canvas.height;\n\n    const ctx = canvas.getContext('2d')!;\n    const imgData = ctx.getImageData(0, 0, width, height);\n\n    return PointContainer.fromImageData(imgData);\n  }\n\n  static fromImageData(imageData: ImageData) {\n    const width = imageData.width;\n    const height = imageData.height;\n\n    return PointContainer.fromUint8Array(imageData.data, width, height);\n  }\n\n  static fromUint8Array(\n    uint8Array: number[] | Uint8Array | Uint8ClampedArray,\n    width: number,\n    height: number,\n  ) {\n    switch (Object.prototype.toString.call(uint8Array)) {\n      case '[object Uint8ClampedArray]':\n      case '[object Uint8Array]':\n        break;\n\n      default:\n        uint8Array = new Uint8Array(uint8Array);\n    }\n\n    const uint32Array = new Uint32Array((uint8Array as Uint8Array).buffer);\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n\n  static fromUint32Array(\n    uint32Array: Uint32Array,\n    width: number,\n    height: number,\n  ) {\n    const container = new PointContainer();\n\n    container._width = width;\n    container._height = height;\n\n    for (let i = 0, l = uint32Array.length; i < l; i++) {\n      container._pointArray[i] = Point.createByUint32(uint32Array[i] | 0); // \"| 0\" is added for v8 optimization\n    }\n\n    return container;\n  }\n\n  static fromBuffer(buffer: Buffer, width: number, height: number) {\n    const uint32Array = new Uint32Array(\n      buffer.buffer,\n      buffer.byteOffset,\n      buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT,\n    );\n    return PointContainer.fromUint32Array(uint32Array, width, height);\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * palette.ts - part of Image Quantization Library\n */\n\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { rgb2hsl } from '../conversion/rgb2hsl';\n\n// TODO: make paletteArray via pointContainer, so, export will be available via pointContainer.exportXXX\n\nconst hueGroups = 10;\n\nexport function hueGroup(hue: number, segmentsNumber: number) {\n  const maxHue = 360;\n  const seg = maxHue / segmentsNumber;\n  const half = seg / 2;\n\n  for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\n    if (hue >= mid && hue < mid + seg) return i;\n  }\n  return 0;\n}\n\nexport class Palette {\n  private readonly _pointContainer: PointContainer;\n  private readonly _pointArray: Point[] = [];\n  private _i32idx: { [key: string]: number } = {};\n\n  constructor() {\n    this._pointContainer = new PointContainer();\n    this._pointContainer.setHeight(1);\n    this._pointArray = this._pointContainer.getPointArray();\n  }\n\n  add(color: Point) {\n    this._pointArray.push(color);\n    this._pointContainer.setWidth(this._pointArray.length);\n  }\n\n  has(color: Point) {\n    for (let i = this._pointArray.length - 1; i >= 0; i--) {\n      if (color.uint32 === this._pointArray[i].uint32) return true;\n    }\n\n    return false;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\n  getNearestColor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    color: Point,\n  ) {\n    return this._pointArray[\n      this._getNearestIndex(colorDistanceCalculator, color) | 0\n    ];\n  }\n\n  getPointContainer() {\n    return this._pointContainer;\n  }\n\n  // TOTRY: use HUSL - http://boronine.com/husl/\n  /*\n   public nearestIndexByUint32(i32) {\n   var idx : number = this._nearestPointFromCache(\"\" + i32);\n   if (idx >= 0) return idx;\n\n   var min = 1000,\n   rgb = [\n   (i32 & 0xff),\n   (i32 >>> 8) & 0xff,\n   (i32 >>> 16) & 0xff,\n   (i32 >>> 24) & 0xff\n   ],\n   len = this._pointArray.length;\n\n   idx = 0;\n   for (var i = 0; i < len; i++) {\n   var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\n\n   if (dist < min) {\n   min = dist;\n   idx = i;\n   }\n   }\n\n   this._i32idx[i32] = idx;\n   return idx;\n   }\n   */\n\n  private _nearestPointFromCache(key: string) {\n    return typeof this._i32idx[key] === 'number' ? this._i32idx[key] : -1;\n  }\n\n  private _getNearestIndex(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    point: Point,\n  ) {\n    let idx = this._nearestPointFromCache('' + point.uint32);\n    if (idx >= 0) return idx;\n\n    let minimalDistance = Number.MAX_VALUE;\n\n    idx = 0;\n    for (let i = 0, l = this._pointArray.length; i < l; i++) {\n      const p = this._pointArray[i];\n      const distance = colorDistanceCalculator.calculateRaw(\n        point.r,\n        point.g,\n        point.b,\n        point.a,\n        p.r,\n        p.g,\n        p.b,\n        p.a,\n      );\n\n      if (distance < minimalDistance) {\n        minimalDistance = distance;\n        idx = i;\n      }\n    }\n\n    this._i32idx[point.uint32] = idx;\n    return idx;\n  }\n\n  /*\n   public reduce(histogram : ColorHistogram, colors : number) {\n   if (this._pointArray.length > colors) {\n   var idxi32 = histogram.getImportanceSortedColorsIDXI32();\n\n   // quantize histogram to existing palette\n   var keep = [], uniqueColors = 0, idx, pruned = false;\n\n   for (var i = 0, len = idxi32.length; i < len; i++) {\n   // palette length reached, unset all remaining colors (sparse palette)\n   if (uniqueColors >= colors) {\n   this.prunePal(keep);\n   pruned = true;\n   break;\n   } else {\n   idx = this.nearestIndexByUint32(idxi32[i]);\n   if (keep.indexOf(idx) < 0) {\n   keep.push(idx);\n   uniqueColors++;\n   }\n   }\n   }\n\n   if (!pruned) {\n   this.prunePal(keep);\n   }\n   }\n   }\n\n   // TODO: check usage, not tested!\n   public prunePal(keep : number[]) {\n   var colors = this._pointArray.length;\n   for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n   if (keep.indexOf(colorIndex) < 0) {\n\n   if(colorIndex + 1 < colors) {\n   this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\n   }\n   --colors;\n   //this._pointArray[colorIndex] = null;\n   }\n   }\n   console.log(\"colors pruned: \" + (this._pointArray.length - colors));\n   this._pointArray.length = colors;\n   this._i32idx = {};\n   }\n   */\n\n  // TODO: group very low lum and very high lum colors\n  // TODO: pass custom sort order\n  // TODO: sort criteria function should be placed to HueStats class\n  sort() {\n    this._i32idx = {};\n    this._pointArray.sort((a: Point, b: Point) => {\n      const hslA = rgb2hsl(a.r, a.g, a.b);\n      const hslB = rgb2hsl(b.r, b.g, b.b);\n\n      // sort all grays + whites together\n      const hueA =\n        a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups);\n      const hueB =\n        b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);\n      /*\n       var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\n       var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\n       */\n\n      const hueDiff = hueB - hueA;\n      if (hueDiff) return -hueDiff;\n\n      /*\n       var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\n       if (lumDiff) return -lumDiff;\n       */\n      const lA = a.getLuminosity(true);\n      const lB = b.getLuminosity(true);\n\n      if (lB - lA !== 0) return lB - lA;\n\n      const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\n      if (satDiff) return -satDiff;\n\n      return 0;\n    });\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nimport * as arithmetic from './arithmetic';\nimport { HueStatistics } from './hueStatistics';\nimport { Palette } from './palette';\nimport { Point } from './point';\nimport { PointContainer } from './pointContainer';\nimport { ProgressTracker } from './progressTracker';\n\nexport {\n  Point,\n  PointContainer,\n  Palette,\n  HueStatistics,\n  ProgressTracker,\n  arithmetic,\n};\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * hueStatistics.ts - part of Image Quantization Library\n */\nimport { rgb2hsl } from '../conversion/rgb2hsl';\nimport { hueGroup } from './palette';\n\nclass HueGroup {\n  num = 0;\n  cols: number[] = [];\n}\n\nexport class HueStatistics {\n  private _numGroups: number;\n  private _minCols: number;\n  private _stats: HueGroup[];\n  private _groupsFull: number;\n\n  constructor(numGroups: number, minCols: number) {\n    this._numGroups = numGroups;\n    this._minCols = minCols;\n    this._stats = [];\n\n    for (let i = 0; i <= numGroups; i++) {\n      this._stats[i] = new HueGroup();\n    }\n\n    this._groupsFull = 0;\n  }\n\n  check(i32: number) {\n    if (this._groupsFull === this._numGroups + 1) {\n      this.check = () => {};\n    }\n\n    const r = i32 & 0xff;\n    const g = (i32 >>> 8) & 0xff;\n    const b = (i32 >>> 16) & 0xff;\n    const hg =\n      r === g && g === b\n        ? 0\n        : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups);\n    const gr = this._stats[hg];\n    const min = this._minCols;\n\n    gr.num++;\n\n    if (gr.num > min) {\n      return;\n    }\n    if (gr.num === min) {\n      this._groupsFull++;\n    }\n\n    if (gr.num <= min) {\n      this._stats[hg].cols.push(i32);\n    }\n  }\n\n  injectIntoDictionary(histG: Record<string, number>) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col: number) => {\n          if (!histG[col]) {\n            histG[col] = 1;\n          } else {\n            histG[col]++;\n          }\n        });\n      }\n    }\n  }\n\n  injectIntoArray(histG: string[]) {\n    for (let i = 0; i <= this._numGroups; i++) {\n      if (this._stats[i].num <= this._minCols) {\n        this._stats[i].cols.forEach((col: unknown) => {\n          if (histG.indexOf(col as string) === -1) {\n            histG.push(col as string);\n          }\n        });\n      }\n    }\n  }\n}\n","export class ProgressTracker {\n  static readonly steps = 100;\n\n  progress: number;\n\n  private _step: number;\n  private _range: number;\n  private _last: number;\n  private _progressRange: number;\n\n  constructor(valueRange: number, progressRange: number) {\n    this._range = valueRange;\n    this._progressRange = progressRange;\n    this._step = Math.max(1, (this._range / (ProgressTracker.steps + 1)) | 0);\n    this._last = -this._step;\n    this.progress = 0;\n  }\n\n  shouldNotify(current: number) {\n    if (current - this._last >= this._step) {\n      this._last = current;\n      this.progress = Math.min(\n        (this._progressRange * this._last) / this._range,\n        this._progressRange,\n      );\n      return true;\n    }\n\n    return false;\n  }\n}\n","/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\n\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass Neuron {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r | 0;\n    this.g -= g | 0;\n    this.b -= b | 0;\n    this.a -= a | 0;\n  }\n\n  /*\n   public subtract(r : number, g : number, b : number, a : number) : void {\n   this.r = (-r + this.r) | 0;\n   this.g = (-g + this.g) | 0;\n   this.b = (-b + this.b) | 0;\n   this.a = (-a + this.a) | 0;\n\n   this.r -= r;\n   this.g -= g;\n   this.b -= b;\n   this.a -= a;\n\n   this.r -= r | 0;\n   this.g -= g | 0;\n   this.b -= b | 0;\n   this.a -= a | 0;\n   }\n   */\n}\n\nexport class NeuQuant extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuant._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuant._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuant._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta = NeuQuant._initialBias >> NeuQuant._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuant._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuant._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuant._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuant._alphaRadBiasShift;\n\n  private _pointArray: Point[];\n  private readonly _networkSize: number;\n  private _network!: Neuron[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize(): IterableIterator<PaletteQuantizerYieldValue> {\n    this._init();\n\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new Neuron(\n        ((i << (networkBiasShift + 8)) / this._networkSize) | 0,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = (NeuQuant._initialBias / this._networkSize) | 0;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn() {\n    let sampleFactor = this._sampleFactor;\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuant._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = (30 + (sampleFactor - 1) / 3) | 0;\n    const pointsToSample = (pointsNumber / sampleFactor) | 0;\n\n    let delta = (pointsToSample / NeuQuant._nCycles) | 0;\n    let alpha = NeuQuant._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\n\n    let rad = radius >> NeuQuant._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        (alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad))) >>>\n        0;\n    }\n\n    let step;\n    if (pointsNumber < NeuQuant._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuant._prime1 !== 0) {\n      step = NeuQuant._prime1;\n    } else if (pointsNumber % NeuQuant._prime2 !== 0) {\n      step = NeuQuant._prime2;\n    } else if (pointsNumber % NeuQuant._prime3 !== 0) {\n      step = NeuQuant._prime3;\n    } else {\n      step = NeuQuant._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= (alpha / alphadec) | 0;\n        radius -= (radius / NeuQuant._radiusDecrease) | 0;\n        rad = radius >> NeuQuant._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            (alpha *\n              (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad))) >>>\n            0;\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuant._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuant._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, a: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        (this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier) |\n        0;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuant._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuant._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuant._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuant._beta;\n    this._bias[bestpos] -= NeuQuant._betaGamma;\n    return bestbiaspos;\n  }\n}\n","/*\n * NeuQuantFloat Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * neuquant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\n// bias for colour values\nconst networkBiasShift = 3;\n\nclass NeuronFloat {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n\n  constructor(defaultValue: number) {\n    this.r = this.g = this.b = this.a = defaultValue;\n  }\n\n  /**\n   * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\n   * @example\n   * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\n   */\n  toPoint() {\n    return Point.createByRGBA(\n      this.r >> networkBiasShift,\n      this.g >> networkBiasShift,\n      this.b >> networkBiasShift,\n      this.a >> networkBiasShift,\n    );\n  }\n\n  subtract(r: number, g: number, b: number, a: number) {\n    this.r -= r;\n    this.g -= g;\n    this.b -= b;\n    this.a -= a;\n  }\n}\n\nexport class NeuQuantFloat extends AbstractPaletteQuantizer {\n  /*\n   four primes near 500 - assume no image has a length so large\n   that it is divisible by all four primes\n   */\n  private static readonly _prime1 = 499;\n  private static readonly _prime2 = 491;\n  private static readonly _prime3 = 487;\n  private static readonly _prime4 = 503;\n  private static readonly _minpicturebytes = NeuQuantFloat._prime4;\n\n  // no. of learning cycles\n  private static readonly _nCycles = 100;\n\n  // defs for freq and bias\n  private static readonly _initialBiasShift = 16;\n\n  // bias for fractions\n  private static readonly _initialBias = 1 << NeuQuantFloat._initialBiasShift;\n  private static readonly _gammaShift = 10;\n\n  // gamma = 1024\n  // TODO: why gamma is never used?\n  // private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\n  private static readonly _betaShift = 10;\n  private static readonly _beta =\n    NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift;\n\n  // beta = 1/1024\n  private static readonly _betaGamma =\n    NeuQuantFloat._initialBias <<\n    (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift);\n\n  /*\n   * for 256 cols, radius starts\n   */\n  private static readonly _radiusBiasShift = 6;\n\n  // at 32.0 biased by 6 bits\n  private static readonly _radiusBias = 1 << NeuQuantFloat._radiusBiasShift;\n\n  // and decreases by a factor of 1/30 each cycle\n  private static readonly _radiusDecrease = 30;\n\n  /* defs for decreasing alpha factor */\n\n  // alpha starts at 1.0\n  private static readonly _alphaBiasShift = 10;\n\n  // biased by 10 bits\n  private static readonly _initAlpha = 1 << NeuQuantFloat._alphaBiasShift;\n\n  /* radBias and alphaRadBias used for radpower calculation */\n  private static readonly _radBiasShift = 8;\n  private static readonly _radBias = 1 << NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBiasShift =\n    NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\n  private static readonly _alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift;\n\n  private _pointArray!: Point[];\n  private readonly _networkSize!: number;\n  private _network!: NeuronFloat[];\n\n  /** sampling factor 1..30 */\n  private readonly _sampleFactor!: number;\n  private _radPower!: number[];\n\n  // bias and freq arrays for learning\n  private _freq!: number[];\n\n  /* for network lookup - really 256 */\n  private _bias!: number[];\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._pointArray = [];\n    this._sampleFactor = 1;\n    this._networkSize = colors;\n\n    this._distance.setWhitePoint(\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n      255 << networkBiasShift,\n    );\n  }\n\n  sample(pointContainer: PointContainer) {\n    this._pointArray = this._pointArray.concat(pointContainer.getPointArray());\n  }\n\n  *quantize() {\n    this._init();\n    yield* this._learn();\n\n    yield {\n      palette: this._buildPalette(),\n      progress: 100,\n    };\n  }\n\n  private _init() {\n    this._freq = [];\n    this._bias = [];\n    this._radPower = [];\n    this._network = [];\n    for (let i = 0; i < this._networkSize; i++) {\n      this._network[i] = new NeuronFloat(\n        (i << (networkBiasShift + 8)) / this._networkSize,\n      );\n\n      // 1/this._networkSize\n      this._freq[i] = NeuQuantFloat._initialBias / this._networkSize;\n      this._bias[i] = 0;\n    }\n  }\n\n  /**\n   * Main Learning Loop\n   */\n  private *_learn(): IterableIterator<PaletteQuantizerYieldValue> {\n    let sampleFactor = this._sampleFactor;\n\n    const pointsNumber = this._pointArray.length;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\n\n    const alphadec = 30 + (sampleFactor - 1) / 3;\n    const pointsToSample = pointsNumber / sampleFactor;\n\n    let delta = (pointsToSample / NeuQuantFloat._nCycles) | 0;\n    let alpha = NeuQuantFloat._initAlpha;\n    let radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\n\n    let rad = radius >> NeuQuantFloat._radiusBiasShift;\n    if (rad <= 1) rad = 0;\n\n    for (let i = 0; i < rad; i++) {\n      this._radPower[i] =\n        alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\n    }\n\n    let step;\n    if (pointsNumber < NeuQuantFloat._minpicturebytes) {\n      step = 1;\n    } else if (pointsNumber % NeuQuantFloat._prime1 !== 0) {\n      step = NeuQuantFloat._prime1;\n    } else if (pointsNumber % NeuQuantFloat._prime2 !== 0) {\n      step = NeuQuantFloat._prime2;\n    } else if (pointsNumber % NeuQuantFloat._prime3 !== 0) {\n      step = NeuQuantFloat._prime3;\n    } else {\n      step = NeuQuantFloat._prime4;\n    }\n\n    const tracker = new ProgressTracker(pointsToSample, 99);\n    for (let i = 0, pointIndex = 0; i < pointsToSample; ) {\n      if (tracker.shouldNotify(i)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      const point = this._pointArray[pointIndex];\n      const b = point.b << networkBiasShift;\n      const g = point.g << networkBiasShift;\n      const r = point.r << networkBiasShift;\n      const a = point.a << networkBiasShift;\n      const neuronIndex = this._contest(b, g, r, a);\n\n      this._alterSingle(alpha, neuronIndex, b, g, r, a);\n      if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\n\n      /* alter neighbours */\n      pointIndex += step;\n      if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / NeuQuantFloat._radiusDecrease;\n        rad = radius >> NeuQuantFloat._radiusBiasShift;\n\n        if (rad <= 1) rad = 0;\n        for (let j = 0; j < rad; j++) {\n          this._radPower[j] =\n            alpha *\n            (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\n        }\n      }\n    }\n  }\n\n  private _buildPalette() {\n    const palette = new Palette();\n\n    this._network.forEach((neuron) => {\n      palette.add(neuron.toPoint());\n    });\n\n    palette.sort();\n    return palette;\n  }\n\n  /**\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\n   */\n  private _alterNeighbour(\n    rad: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    al: number,\n  ) {\n    let lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    let hi = i + rad;\n    if (hi > this._networkSize) hi = this._networkSize;\n\n    let j = i + 1;\n    let k = i - 1;\n    let m = 1;\n\n    while (j < hi || k > lo) {\n      const a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;\n      if (j < hi) {\n        const p = this._network[j++];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n\n      if (k > lo) {\n        const p = this._network[k--];\n        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));\n      }\n    }\n  }\n\n  /**\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   */\n  private _alterSingle(\n    alpha: number,\n    i: number,\n    b: number,\n    g: number,\n    r: number,\n    a: number,\n  ) {\n    alpha /= NeuQuantFloat._initAlpha;\n\n    /* alter hit neuron */\n    const n = this._network[i];\n    n.subtract(\n      alpha * (n.r - r),\n      alpha * (n.g - g),\n      alpha * (n.b - b),\n      alpha * (n.a - a),\n    );\n  }\n\n  /**\n   * Search for biased BGR values\n   * description:\n   *    finds closest neuron (min dist) and updates freq\n   *    finds best neuron (min dist-bias) and returns position\n   *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\n   *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\n   *\n   * Original distance equation:\n   *        dist = abs(dR) + abs(dG) + abs(dB)\n   */\n  private _contest(b: number, g: number, r: number, al: number) {\n    const multiplier = (255 * 4) << networkBiasShift;\n\n    let bestd = ~(1 << 31);\n    let bestbiasd = bestd;\n    let bestpos = -1;\n    let bestbiaspos = bestpos;\n\n    for (let i = 0; i < this._networkSize; i++) {\n      const n = this._network[i];\n      const dist =\n        this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      const biasdist =\n        dist -\n        (this._bias[i] >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n      const betafreq = this._freq[i] >> NeuQuantFloat._betaShift;\n      this._freq[i] -= betafreq;\n      this._bias[i] += betafreq << NeuQuantFloat._gammaShift;\n    }\n    this._freq[bestpos] += NeuQuantFloat._beta;\n    this._bias[bestpos] -= NeuQuantFloat._betaGamma;\n    return bestbiaspos;\n  }\n}\n","/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * ColorHistogram.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * colorHistogram.ts - part of Image Quantization Library\n */\nimport { HueStatistics } from '../../utils/hueStatistics';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { stableSort } from '../../utils/arithmetic';\n\ninterface Box {\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n}\n\nexport class ColorHistogram {\n  private static _boxSize = [64, 64];\n  private static _boxPixels = 2;\n  private static _hueGroups = 10;\n\n  // 1 = by global population, 2 = subregion population threshold\n  private _method: number;\n\n  // HueStatistics instance\n  private _hueStats: HueStatistics;\n\n  private _histogram: { [color: string]: number };\n\n  // # of highest-frequency colors to start with for palette reduction\n  private _initColors: number;\n\n  // if > 0, enables hues stats and min-color retention per group\n  private _minHueCols: number;\n\n  constructor(method: number, colors: number) {\n    // 1 = by global population, 2 = subregion population threshold\n    this._method = method;\n\n    // if > 0, enables hues stats and min-color retention per group\n    this._minHueCols = colors << 2; // opts.minHueCols || 0;\n\n    // # of highest-frequency colors to start with for palette reduction\n    this._initColors = colors << 2;\n\n    // HueStatistics instance\n    this._hueStats = new HueStatistics(\n      ColorHistogram._hueGroups,\n      this._minHueCols,\n    );\n\n    this._histogram = Object.create(null);\n  }\n\n  sample(pointContainer: PointContainer) {\n    switch (this._method) {\n      case 1:\n        this._colorStats1D(pointContainer);\n        break;\n      case 2:\n        this._colorStats2D(pointContainer);\n        break;\n    }\n  }\n\n  getImportanceSortedColorsIDXI32() {\n    // TODO: fix typing issue in stableSort func\n    const sorted = stableSort(\n      Object.keys(this._histogram),\n      (a, b) => this._histogram[b] - this._histogram[a],\n    );\n    if (sorted.length === 0) {\n      return [];\n    }\n\n    let idxi32;\n    switch (this._method) {\n      case 1:\n        const initialColorsLimit = Math.min(sorted.length, this._initColors);\n        const last = sorted[initialColorsLimit - 1];\n        const freq = this._histogram[last];\n\n        idxi32 = sorted.slice(0, initialColorsLimit);\n\n        // add any cut off colors with same freq as last\n        let pos = initialColorsLimit;\n        const len = sorted.length;\n        while (pos < len && this._histogram[sorted[pos]] === freq) {\n          idxi32.push(sorted[pos++]);\n        }\n\n        // inject min huegroup colors\n        this._hueStats.injectIntoArray(idxi32);\n        break;\n\n      case 2:\n        idxi32 = sorted;\n        break;\n\n      default:\n        // TODO: rethink errors\n        throw new Error('Incorrect method');\n    }\n\n    // int32-ify values\n    return idxi32.map((v) => +v);\n  }\n\n  // global top-population\n  private _colorStats1D(pointContainer: PointContainer) {\n    const histG = this._histogram;\n    const pointArray = pointContainer.getPointArray();\n    const len = pointArray.length;\n\n    for (let i = 0; i < len; i++) {\n      const col = pointArray[i].uint32;\n\n      // collect hue stats\n      this._hueStats.check(col);\n\n      if (col in histG) {\n        histG[col]++;\n      } else {\n        histG[col] = 1;\n      }\n    }\n  }\n\n  // population threshold within subregions\n  // FIXME: this can over-reduce (few/no colors same?), need a way to keep\n  // important colors that dont ever reach local thresholds (gradients?)\n  private _colorStats2D(pointContainer: PointContainer) {\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const pointArray = pointContainer.getPointArray();\n\n    const boxW = ColorHistogram._boxSize[0];\n    const boxH = ColorHistogram._boxSize[1];\n    const area = boxW * boxH;\n    const boxes = this._makeBoxes(width, height, boxW, boxH);\n    const histG = this._histogram;\n\n    boxes.forEach((box) => {\n      let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\n      if (effc < 2) effc = 2;\n\n      const histL: Record<string, number> = {};\n      this._iterateBox(box, width, (i) => {\n        const col = pointArray[i].uint32;\n\n        // collect hue stats\n        this._hueStats.check(col);\n\n        if (col in histG) {\n          histG[col]++;\n        } else if (col in histL) {\n          if (++histL[col] >= effc) {\n            histG[col] = histL[col];\n          }\n        } else {\n          histL[col] = 1;\n        }\n      });\n    });\n\n    // inject min huegroup colors\n    this._hueStats.injectIntoDictionary(histG);\n  }\n\n  // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\n  private _iterateBox(bbox: Box, wid: number, fn: (i: number) => void) {\n    const b = bbox;\n    const i0 = b.y * wid + b.x;\n    const i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1);\n    const incr = wid - b.w + 1;\n\n    let cnt = 0;\n    let i = i0;\n\n    do {\n      fn.call(this, i);\n      i += ++cnt % b.w === 0 ? incr : 1;\n    } while (i <= i1);\n  }\n\n  /**\n   *    partitions a rectangle of width x height into\n   *    array of boxes stepX x stepY (or less)\n   */\n  private _makeBoxes(\n    width: number,\n    height: number,\n    stepX: number,\n    stepY: number,\n  ) {\n    const wrem = width % stepX;\n    const hrem = height % stepY;\n    const xend = width - wrem;\n    const yend = height - hrem;\n    const boxesArray = [];\n\n    for (let y = 0; y < height; y += stepY) {\n      for (let x = 0; x < width; x += stepX) {\n        boxesArray.push({\n          x,\n          y,\n          w: x === xend ? wrem : stepX,\n          h: y === yend ? hrem : stepY,\n        });\n      }\n    }\n\n    return boxesArray;\n  }\n}\n","/*\n * Copyright (c) 2015, Leon Sorokin\n * All rights reserved. (MIT Licensed)\n *\n * RGBQuant.js - an image quantization lib\n */\n\n/**\n * @preserve TypeScript port:\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * rgbquant.ts - part of Image Quantization Library\n */\n\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { ColorHistogram } from './colorHistogram';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { stableSort } from '../../utils/arithmetic';\nimport { ProgressTracker } from '../../utils';\n\nclass RemovedColor {\n  readonly index: number;\n  readonly color: Point;\n  readonly distance: number;\n\n  constructor(index: number, color: Point, distance: number) {\n    this.index = index;\n    this.color = color;\n    this.distance = distance;\n  }\n}\n\n// TODO: make input/output image and input/output palettes with instances of class Point only!\nexport class RGBQuant extends AbstractPaletteQuantizer {\n  // desired final palette size\n  private readonly _colors: number;\n\n  // color-distance threshold for initial reduction pass\n  private readonly _initialDistance: number;\n\n  // subsequent passes threshold\n  private readonly _distanceIncrement: number;\n\n  // accumulated histogram\n  private readonly _histogram: ColorHistogram;\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n    method = 2,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    // desired final palette size\n    this._colors = colors;\n\n    // histogram to accumulate\n    this._histogram = new ColorHistogram(method, colors);\n\n    this._initialDistance = 0.01;\n    this._distanceIncrement = 0.005;\n  }\n\n  // gathers histogram info\n  sample(image: PointContainer) {\n    /*\n     var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\n\n     for (var i = 0, l = pointArray.length; i < l; i++) {\n     var color = pointArray[i];\n     for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\n     if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\n     if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\n     }\n     }\n     var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\n     this._distance.setWhitePoint(rd, gd, bd, ad);\n\n     this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\n     */\n\n    this._histogram.sample(image);\n  }\n\n  // reduces histogram to palette, remaps & memoizes reduced colors\n  *quantize() {\n    const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();\n    if (idxi32.length === 0) {\n      throw new Error('No colors in image');\n    }\n\n    yield* this._buildPalette(idxi32);\n  }\n\n  // reduces similar colors from an importance-sorted Uint32 rgba array\n  private *_buildPalette(\n    idxi32: number[],\n  ): IterableIterator<PaletteQuantizerYieldValue> {\n    // reduce histogram to create initial palette\n    // build full rgb palette\n    const palette = new Palette();\n    const colorArray = palette.getPointContainer().getPointArray();\n    const usageArray = new Array(idxi32.length);\n\n    for (let i = 0; i < idxi32.length; i++) {\n      colorArray.push(Point.createByUint32(idxi32[i]));\n      usageArray[i] = 1;\n    }\n\n    const len = colorArray.length;\n    const memDist = [];\n\n    let palLen = len;\n    let thold = this._initialDistance;\n\n    // palette already at or below desired length\n    const tracker = new ProgressTracker(palLen - this._colors, 99);\n    while (palLen > this._colors) {\n      memDist.length = 0;\n\n      // iterate palette\n      for (let i = 0; i < len; i++) {\n        if (tracker.shouldNotify(len - palLen)) {\n          yield {\n            progress: tracker.progress,\n          };\n        }\n\n        if (usageArray[i] === 0) continue;\n        const pxi = colorArray[i];\n        // if (!pxi) continue;\n\n        for (let j = i + 1; j < len; j++) {\n          if (usageArray[j] === 0) continue;\n          const pxj = colorArray[j];\n          // if (!pxj) continue;\n\n          const dist = this._distance.calculateNormalized(pxi, pxj);\n          if (dist < thold) {\n            // store index,rgb,dist\n            memDist.push(new RemovedColor(j, pxj, dist));\n            usageArray[j] = 0;\n            palLen--;\n          }\n        }\n      }\n      // palette reduction pass\n      // console.log(\"palette length: \" + palLen);\n\n      // if palette is still much larger than target, increment by larger initDist\n      thold +=\n        palLen > this._colors * 3\n          ? this._initialDistance\n          : this._distanceIncrement;\n    }\n\n    // if palette is over-reduced, re-add removed colors with largest distances from last round\n    if (palLen < this._colors) {\n      // sort descending\n      stableSort(memDist, (a, b) => b.distance - a.distance);\n\n      let k = 0;\n      while (palLen < this._colors && k < memDist.length) {\n        const removedColor = memDist[k];\n        // re-inject rgb into final palette\n        usageArray[removedColor.index] = 1;\n        palLen++;\n        k++;\n      }\n    }\n\n    let colors = colorArray.length;\n    for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\n      if (usageArray[colorIndex] === 0) {\n        if (colorIndex !== colors - 1) {\n          colorArray[colorIndex] = colorArray[colors - 1];\n        }\n        --colors;\n      }\n    }\n    colorArray.length = colors;\n\n    palette.sort();\n\n    yield {\n      palette,\n      progress: 100,\n    };\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * wuQuant.ts - part of Image Quantization Library\n */\nimport { Palette } from '../../utils/palette';\nimport { Point } from '../../utils/point';\nimport { PointContainer } from '../../utils/pointContainer';\nimport { AbstractDistanceCalculator } from '../../distance/distanceCalculator';\nimport { AbstractPaletteQuantizer } from '../paletteQuantizer';\nimport { PaletteQuantizerYieldValue } from '../paletteQuantizerYieldValue';\nimport { ProgressTracker } from '../../utils';\n\nfunction createArray1D(dimension1: number) {\n  const a = [];\n  for (let k = 0; k < dimension1; k++) {\n    a[k] = 0;\n  }\n  return a;\n}\n\nfunction createArray4D(\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n  dimension4: number,\n): number[][][][] {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = new Array(dimension4);\n        for (let l = 0; l < dimension4; l++) {\n          a[i][j][k][l] = 0;\n        }\n      }\n    }\n  }\n  return a;\n}\n\nfunction createArray3D(\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n): number[][][] {\n  const a = new Array(dimension1);\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = new Array(dimension2);\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = new Array(dimension3);\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = 0;\n      }\n    }\n  }\n  return a;\n}\n\nfunction fillArray3D<T>(\n  a: T[][][],\n  dimension1: number,\n  dimension2: number,\n  dimension3: number,\n  value: T,\n) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = [];\n    for (let j = 0; j < dimension2; j++) {\n      a[i][j] = [];\n      for (let k = 0; k < dimension3; k++) {\n        a[i][j][k] = value;\n      }\n    }\n  }\n}\n\nfunction fillArray1D<T>(a: T[], dimension1: number, value: T) {\n  for (let i = 0; i < dimension1; i++) {\n    a[i] = value;\n  }\n}\n\nexport class WuColorCube {\n  redMinimum!: number;\n  redMaximum!: number;\n  greenMinimum!: number;\n  greenMaximum!: number;\n  blueMinimum!: number;\n  blueMaximum!: number;\n  volume!: number;\n  alphaMinimum!: number;\n  alphaMaximum!: number;\n}\n\nexport class WuQuant extends AbstractPaletteQuantizer {\n  private static readonly _alpha = 3;\n  private static readonly _red = 2;\n  private static readonly _green = 1;\n  private static readonly _blue = 0;\n\n  private _reds!: number[];\n  private _greens!: number[];\n  private _blues!: number[];\n  private _alphas!: number[];\n  private _sums!: number[];\n\n  private _weights!: number[][][][];\n  private _momentsRed!: number[][][][];\n  private _momentsGreen!: number[][][][];\n  private _momentsBlue!: number[][][][];\n  private _momentsAlpha!: number[][][][];\n  private _moments!: number[][][][];\n  private _table!: number[];\n  private _pixels!: Point[];\n\n  private _cubes!: WuColorCube[];\n  private _colors!: number;\n\n  private _significantBitsPerChannel!: number;\n  private _maxSideIndex!: number;\n  private _alphaMaxSideIndex!: number;\n  private _sideSize!: number;\n  private _alphaSideSize!: number;\n\n  private readonly _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    colors = 256,\n    significantBitsPerChannel = 5,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._setQuality(significantBitsPerChannel);\n    this._initialize(colors);\n  }\n\n  sample(image: PointContainer) {\n    const pointArray = image.getPointArray();\n\n    for (let i = 0, l = pointArray.length; i < l; i++) {\n      this._addColor(pointArray[i]);\n    }\n\n    this._pixels = this._pixels.concat(pointArray);\n  }\n\n  *quantize() {\n    yield* this._preparePalette();\n\n    const palette = new Palette();\n\n    // generates palette\n    for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\n      if (this._sums[paletteIndex] > 0) {\n        const sum = this._sums[paletteIndex];\n        const r = this._reds[paletteIndex] / sum;\n        const g = this._greens[paletteIndex] / sum;\n        const b = this._blues[paletteIndex] / sum;\n        const a = this._alphas[paletteIndex] / sum;\n\n        const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\n        palette.add(color);\n      }\n    }\n\n    palette.sort();\n\n    yield {\n      palette,\n      progress: 100,\n    };\n  }\n\n  private *_preparePalette() {\n    // preprocess the colors\n    yield* this._calculateMoments();\n\n    let next = 0;\n    const volumeVariance = createArray1D(this._colors);\n\n    // processes the cubes\n    for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\n      // if cut is possible; make it\n      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {\n        volumeVariance[next] =\n          this._cubes[next].volume > 1\n            ? this._calculateVariance(this._cubes[next])\n            : 0.0;\n        volumeVariance[cubeIndex] =\n          this._cubes[cubeIndex].volume > 1\n            ? this._calculateVariance(this._cubes[cubeIndex])\n            : 0.0;\n      } else {\n        // the cut was not possible, revert the index\n        volumeVariance[next] = 0.0;\n        cubeIndex--;\n      }\n\n      next = 0;\n      let temp = volumeVariance[0];\n\n      for (let index = 1; index <= cubeIndex; ++index) {\n        if (volumeVariance[index] > temp) {\n          temp = volumeVariance[index];\n          next = index;\n        }\n      }\n\n      if (temp <= 0.0) {\n        this._colors = cubeIndex + 1;\n        break;\n      }\n    }\n\n    const lookupRed = [];\n    const lookupGreen = [];\n    const lookupBlue = [];\n    const lookupAlpha = [];\n\n    // precalculates lookup tables\n    for (let k = 0; k < this._colors; ++k) {\n      const weight = WuQuant._volume(this._cubes[k], this._weights);\n\n      if (weight > 0) {\n        lookupRed[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsRed) / weight) | 0;\n        lookupGreen[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsGreen) / weight) | 0;\n        lookupBlue[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsBlue) / weight) | 0;\n        lookupAlpha[k] =\n          (WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight) | 0;\n      } else {\n        lookupRed[k] = 0;\n        lookupGreen[k] = 0;\n        lookupBlue[k] = 0;\n        lookupAlpha[k] = 0;\n      }\n    }\n\n    this._reds = createArray1D(this._colors + 1);\n    this._greens = createArray1D(this._colors + 1);\n    this._blues = createArray1D(this._colors + 1);\n    this._alphas = createArray1D(this._colors + 1);\n    this._sums = createArray1D(this._colors + 1);\n\n    // scans and adds colors\n    for (let index = 0, l = this._pixels.length; index < l; index++) {\n      const color = this._pixels[index];\n\n      const match = -1;\n\n      let bestMatch = match;\n      let bestDistance = Number.MAX_VALUE;\n\n      for (let lookup = 0; lookup < this._colors; lookup++) {\n        const foundRed = lookupRed[lookup];\n        const foundGreen = lookupGreen[lookup];\n        const foundBlue = lookupBlue[lookup];\n        const foundAlpha = lookupAlpha[lookup];\n\n        const distance = this._distance.calculateRaw(\n          foundRed,\n          foundGreen,\n          foundBlue,\n          foundAlpha,\n          color.r,\n          color.g,\n          color.b,\n          color.a,\n        );\n\n        if (distance < bestDistance) {\n          bestDistance = distance;\n          bestMatch = lookup;\n        }\n      }\n\n      this._reds[bestMatch] += color.r;\n      this._greens[bestMatch] += color.g;\n      this._blues[bestMatch] += color.b;\n      this._alphas[bestMatch] += color.a;\n      this._sums[bestMatch]++;\n    }\n  }\n\n  private _addColor(color: Point) {\n    const bitsToRemove = 8 - this._significantBitsPerChannel;\n    const indexRed = (color.r >> bitsToRemove) + 1;\n    const indexGreen = (color.g >> bitsToRemove) + 1;\n    const indexBlue = (color.b >> bitsToRemove) + 1;\n    const indexAlpha = (color.a >> bitsToRemove) + 1;\n\n    // if(color.a > 10) {\n    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;\n    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;\n    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;\n    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;\n    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;\n    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] +=\n      this._table[color.r] +\n      this._table[color.g] +\n      this._table[color.b] +\n      this._table[color.a];\n    // }\n  }\n\n  /**\n   * Converts the histogram to a series of _moments.\n   */\n  private *_calculateMoments(): IterableIterator<PaletteQuantizerYieldValue> {\n    const area: number[] = [];\n    const areaRed: number[] = [];\n    const areaGreen: number[] = [];\n    const areaBlue: number[] = [];\n    const areaAlpha: number[] = [];\n    const area2: number[] = [];\n\n    const xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize);\n    const xareaRed = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaGreen = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaBlue = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xareaAlpha = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    const xarea2 = createArray3D(\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n\n    let trackerProgress = 0;\n    const tracker = new ProgressTracker(\n      this._alphaMaxSideIndex * this._maxSideIndex,\n      99,\n    );\n\n    for (\n      let alphaIndex = 1;\n      alphaIndex <= this._alphaMaxSideIndex;\n      ++alphaIndex\n    ) {\n      fillArray3D<number>(\n        xarea,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaRed,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaGreen,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaBlue,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xareaAlpha,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n      fillArray3D<number>(\n        xarea2,\n        this._sideSize,\n        this._sideSize,\n        this._sideSize,\n        0,\n      );\n\n      for (\n        let redIndex = 1;\n        redIndex <= this._maxSideIndex;\n        ++redIndex, ++trackerProgress\n      ) {\n        if (tracker.shouldNotify(trackerProgress)) {\n          yield {\n            progress: tracker.progress,\n          };\n        }\n\n        fillArray1D<number>(area, this._sideSize, 0);\n        fillArray1D<number>(areaRed, this._sideSize, 0);\n        fillArray1D<number>(areaGreen, this._sideSize, 0);\n        fillArray1D<number>(areaBlue, this._sideSize, 0);\n        fillArray1D<number>(areaAlpha, this._sideSize, 0);\n        fillArray1D<number>(area2, this._sideSize, 0);\n\n        for (\n          let greenIndex = 1;\n          greenIndex <= this._maxSideIndex;\n          ++greenIndex\n        ) {\n          let line = 0;\n          let lineRed = 0;\n          let lineGreen = 0;\n          let lineBlue = 0;\n          let lineAlpha = 0;\n          let line2 = 0.0;\n\n          for (\n            let blueIndex = 1;\n            blueIndex <= this._maxSideIndex;\n            ++blueIndex\n          ) {\n            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineRed +=\n              this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineGreen +=\n              this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineBlue +=\n              this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];\n            lineAlpha +=\n              this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];\n            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];\n\n            area[blueIndex] += line;\n            areaRed[blueIndex] += lineRed;\n            areaGreen[blueIndex] += lineGreen;\n            areaBlue[blueIndex] += lineBlue;\n            areaAlpha[blueIndex] += lineAlpha;\n            area2[blueIndex] += line2;\n\n            xarea[redIndex][greenIndex][blueIndex] =\n              xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];\n            xareaRed[redIndex][greenIndex][blueIndex] =\n              xareaRed[redIndex - 1][greenIndex][blueIndex] +\n              areaRed[blueIndex];\n            xareaGreen[redIndex][greenIndex][blueIndex] =\n              xareaGreen[redIndex - 1][greenIndex][blueIndex] +\n              areaGreen[blueIndex];\n            xareaBlue[redIndex][greenIndex][blueIndex] =\n              xareaBlue[redIndex - 1][greenIndex][blueIndex] +\n              areaBlue[blueIndex];\n            xareaAlpha[redIndex][greenIndex][blueIndex] =\n              xareaAlpha[redIndex - 1][greenIndex][blueIndex] +\n              areaAlpha[blueIndex];\n            xarea2[redIndex][greenIndex][blueIndex] =\n              xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];\n\n            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] +\n              xarea[redIndex][greenIndex][blueIndex];\n            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsRed[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaRed[redIndex][greenIndex][blueIndex];\n            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaGreen[redIndex][greenIndex][blueIndex];\n            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaBlue[redIndex][greenIndex][blueIndex];\n            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][\n                blueIndex\n              ] + xareaAlpha[redIndex][greenIndex][blueIndex];\n            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] =\n              this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] +\n              xarea2[redIndex][greenIndex][blueIndex];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Computes the volume of the cube in a specific moment.\n   */\n  private static _volumeFloat(cube: WuColorCube, moment: number[][][][]) {\n    return (\n      moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n        cube.blueMaximum\n      ] +\n      moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n        cube.blueMaximum\n      ] -\n      moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n        cube.blueMaximum\n      ] -\n      (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n        cube.blueMinimum\n      ] -\n        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n          cube.blueMinimum\n        ] +\n        moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n          cube.blueMinimum\n        ] -\n        moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n          cube.blueMinimum\n        ])\n    );\n  }\n\n  /**\n   * Computes the volume of the cube in a specific moment.\n   */\n  private static _volume(cube: WuColorCube, moment: number[][][][]) {\n    return WuQuant._volumeFloat(cube, moment) | 0;\n  }\n\n  /**\n   * Splits the cube in given position][and color direction.\n   */\n  private static _top(\n    cube: WuColorCube,\n    direction: number,\n    position: number,\n    moment: number[][][][],\n  ) {\n    let result;\n    switch (direction) {\n      case WuQuant._alpha:\n        result =\n          moment[position][cube.redMaximum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[position][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[position][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[position][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (moment[position][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n            moment[position][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[position][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] +\n            moment[position][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._red:\n        result =\n          moment[cube.alphaMaximum][position][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMaximum][position][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][position][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][position][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (moment[cube.alphaMaximum][position][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n            moment[cube.alphaMaximum][position][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][position][cube.greenMaximum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][position][cube.greenMinimum][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._green:\n        result =\n          moment[cube.alphaMaximum][cube.redMaximum][position][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][position][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMaximum][position][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][position][\n            cube.blueMaximum\n          ] -\n          (moment[cube.alphaMaximum][cube.redMaximum][position][\n            cube.blueMinimum\n          ] -\n            moment[cube.alphaMaximum][cube.redMinimum][position][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMaximum][position][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][position][\n              cube.blueMinimum\n            ]);\n        break;\n\n      case WuQuant._blue:\n        result =\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n            position\n          ] -\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            position\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            position\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            position\n          ] -\n          (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            position\n          ] -\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              position\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              position\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              position\n            ]);\n        break;\n      default:\n        throw new Error('impossible');\n    }\n\n    return result | 0;\n  }\n\n  /**\n   * Splits the cube in a given color direction at its minimum.\n   */\n  private static _bottom(\n    cube: WuColorCube,\n    direction: number,\n    moment: number[][][][],\n  ) {\n    switch (direction) {\n      case WuQuant._alpha:\n        return (\n          -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._red:\n        return (\n          -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._green:\n        return (\n          -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] +\n          moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMaximum\n          ] -\n          (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      case WuQuant._blue:\n        return (\n          -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n          moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][\n            cube.blueMinimum\n          ] +\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][\n            cube.blueMinimum\n          ] -\n          moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][\n            cube.blueMinimum\n          ] -\n          (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][\n            cube.blueMinimum\n          ] +\n            moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][\n              cube.blueMinimum\n            ] +\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][\n              cube.blueMinimum\n            ] -\n            moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][\n              cube.blueMinimum\n            ])\n        );\n\n      default:\n        // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\n        return 0;\n    }\n  }\n\n  /**\n   * Calculates statistical variance for a given cube.\n   */\n  private _calculateVariance(cube: WuColorCube) {\n    const volumeRed = WuQuant._volume(cube, this._momentsRed);\n    const volumeGreen = WuQuant._volume(cube, this._momentsGreen);\n    const volumeBlue = WuQuant._volume(cube, this._momentsBlue);\n    const volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);\n    const volumeMoment = WuQuant._volumeFloat(cube, this._moments);\n    const volumeWeight = WuQuant._volume(cube, this._weights);\n    const distance =\n      volumeRed * volumeRed +\n      volumeGreen * volumeGreen +\n      volumeBlue * volumeBlue +\n      volumeAlpha * volumeAlpha;\n\n    return volumeMoment - distance / volumeWeight;\n  }\n\n  /**\n   * Finds the optimal (maximal) position for the cut.\n   */\n  private _maximize(\n    cube: WuColorCube,\n    direction: number,\n    first: number,\n    last: number,\n    wholeRed: number,\n    wholeGreen: number,\n    wholeBlue: number,\n    wholeAlpha: number,\n    wholeWeight: number,\n  ) {\n    const bottomRed = WuQuant._bottom(cube, direction, this._momentsRed) | 0;\n    const bottomGreen =\n      WuQuant._bottom(cube, direction, this._momentsGreen) | 0;\n    const bottomBlue = WuQuant._bottom(cube, direction, this._momentsBlue) | 0;\n    const bottomAlpha =\n      WuQuant._bottom(cube, direction, this._momentsAlpha) | 0;\n    const bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\n\n    let result = 0.0;\n    let cutPosition = -1;\n\n    for (let position = first; position < last; ++position) {\n      // determines the cube cut at a certain position\n      let halfRed =\n        bottomRed + WuQuant._top(cube, direction, position, this._momentsRed);\n      let halfGreen =\n        bottomGreen +\n        WuQuant._top(cube, direction, position, this._momentsGreen);\n      let halfBlue =\n        bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue);\n      let halfAlpha =\n        bottomAlpha +\n        WuQuant._top(cube, direction, position, this._momentsAlpha);\n      let halfWeight =\n        bottomWeight + WuQuant._top(cube, direction, position, this._weights);\n\n      // the cube cannot be cut at bottom (this would lead to empty cube)\n      if (halfWeight !== 0) {\n        let halfDistance =\n          halfRed * halfRed +\n          halfGreen * halfGreen +\n          halfBlue * halfBlue +\n          halfAlpha * halfAlpha;\n        let temp = halfDistance / halfWeight;\n\n        halfRed = wholeRed - halfRed;\n        halfGreen = wholeGreen - halfGreen;\n        halfBlue = wholeBlue - halfBlue;\n        halfAlpha = wholeAlpha - halfAlpha;\n        halfWeight = wholeWeight - halfWeight;\n\n        if (halfWeight !== 0) {\n          halfDistance =\n            halfRed * halfRed +\n            halfGreen * halfGreen +\n            halfBlue * halfBlue +\n            halfAlpha * halfAlpha;\n          temp += halfDistance / halfWeight;\n\n          if (temp > result) {\n            result = temp;\n            cutPosition = position;\n          }\n        }\n      }\n    }\n\n    return { max: result, position: cutPosition };\n  }\n\n  // Cuts a cube with another one.\n  private _cut(first: WuColorCube, second: WuColorCube) {\n    let direction;\n\n    const wholeRed = WuQuant._volume(first, this._momentsRed);\n    const wholeGreen = WuQuant._volume(first, this._momentsGreen);\n    const wholeBlue = WuQuant._volume(first, this._momentsBlue);\n    const wholeAlpha = WuQuant._volume(first, this._momentsAlpha);\n    const wholeWeight = WuQuant._volume(first, this._weights);\n\n    const red = this._maximize(\n      first,\n      WuQuant._red,\n      first.redMinimum + 1,\n      first.redMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const green = this._maximize(\n      first,\n      WuQuant._green,\n      first.greenMinimum + 1,\n      first.greenMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const blue = this._maximize(\n      first,\n      WuQuant._blue,\n      first.blueMinimum + 1,\n      first.blueMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n    const alpha = this._maximize(\n      first,\n      WuQuant._alpha,\n      first.alphaMinimum + 1,\n      first.alphaMaximum,\n      wholeRed,\n      wholeGreen,\n      wholeBlue,\n      wholeAlpha,\n      wholeWeight,\n    );\n\n    if (\n      alpha.max >= red.max &&\n      alpha.max >= green.max &&\n      alpha.max >= blue.max\n    ) {\n      direction = WuQuant._alpha;\n\n      // cannot split empty cube\n      if (alpha.position < 0) return false;\n    } else if (\n      red.max >= alpha.max &&\n      red.max >= green.max &&\n      red.max >= blue.max\n    ) {\n      direction = WuQuant._red;\n    } else if (\n      green.max >= alpha.max &&\n      green.max >= red.max &&\n      green.max >= blue.max\n    ) {\n      direction = WuQuant._green;\n    } else {\n      direction = WuQuant._blue;\n    }\n\n    second.redMaximum = first.redMaximum;\n    second.greenMaximum = first.greenMaximum;\n    second.blueMaximum = first.blueMaximum;\n    second.alphaMaximum = first.alphaMaximum;\n\n    // cuts in a certain direction\n    switch (direction) {\n      case WuQuant._red:\n        second.redMinimum = first.redMaximum = red.position;\n        second.greenMinimum = first.greenMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._green:\n        second.greenMinimum = first.greenMaximum = green.position;\n        second.redMinimum = first.redMinimum;\n        second.blueMinimum = first.blueMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._blue:\n        second.blueMinimum = first.blueMaximum = blue.position;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        second.alphaMinimum = first.alphaMinimum;\n        break;\n\n      case WuQuant._alpha:\n        second.alphaMinimum = first.alphaMaximum = alpha.position;\n        second.blueMinimum = first.blueMinimum;\n        second.redMinimum = first.redMinimum;\n        second.greenMinimum = first.greenMinimum;\n        break;\n    }\n\n    // determines the volumes after cut\n    first.volume =\n      (first.redMaximum - first.redMinimum) *\n      (first.greenMaximum - first.greenMinimum) *\n      (first.blueMaximum - first.blueMinimum) *\n      (first.alphaMaximum - first.alphaMinimum);\n    second.volume =\n      (second.redMaximum - second.redMinimum) *\n      (second.greenMaximum - second.greenMinimum) *\n      (second.blueMaximum - second.blueMinimum) *\n      (second.alphaMaximum - second.alphaMinimum);\n\n    // the cut was successful\n    return true;\n  }\n\n  private _initialize(colors: number) {\n    this._colors = colors;\n\n    // creates all the _cubes\n    this._cubes = [];\n\n    // initializes all the _cubes\n    for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\n      this._cubes[cubeIndex] = new WuColorCube();\n    }\n\n    // resets the reference minimums\n    this._cubes[0].redMinimum = 0;\n    this._cubes[0].greenMinimum = 0;\n    this._cubes[0].blueMinimum = 0;\n    this._cubes[0].alphaMinimum = 0;\n\n    // resets the reference maximums\n    this._cubes[0].redMaximum = this._maxSideIndex;\n    this._cubes[0].greenMaximum = this._maxSideIndex;\n    this._cubes[0].blueMaximum = this._maxSideIndex;\n    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;\n\n    this._weights = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsRed = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsGreen = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsBlue = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._momentsAlpha = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n    this._moments = createArray4D(\n      this._alphaSideSize,\n      this._sideSize,\n      this._sideSize,\n      this._sideSize,\n    );\n\n    this._table = [];\n    for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\n      this._table[tableIndex] = tableIndex * tableIndex;\n    }\n\n    this._pixels = [];\n  }\n\n  private _setQuality(significantBitsPerChannel = 5) {\n    this._significantBitsPerChannel = significantBitsPerChannel;\n    this._maxSideIndex = 1 << this._significantBitsPerChannel;\n    this._alphaMaxSideIndex = this._maxSideIndex;\n\n    this._sideSize = this._maxSideIndex + 1;\n    this._alphaSideSize = this._alphaMaxSideIndex + 1;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\n\nexport { AbstractImageQuantizer } from './imageQuantizer';\nexport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nexport { NearestColor } from './nearestColor';\nexport { ErrorDiffusionArray, ErrorDiffusionArrayKernel } from './array';\nexport { ErrorDiffusionRiemersma } from './riemersma';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * common.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\n\nexport abstract class AbstractImageQuantizer {\n  abstract quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue>;\n\n  quantizeSync(pointContainer: PointContainer, palette: Palette) {\n    for (const value of this.quantize(pointContainer, palette)) {\n      if (value.pointContainer) {\n        return value.pointContainer;\n      }\n    }\n\n    throw new Error('unreachable');\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * nearestColor.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nimport { ProgressTracker } from '../utils/progressTracker';\n\nexport class NearestColor extends AbstractImageQuantizer {\n  private _distance: AbstractDistanceCalculator;\n\n  constructor(colorDistanceCalculator: AbstractDistanceCalculator) {\n    super();\n    this._distance = colorDistanceCalculator;\n  }\n\n  /**\n   * Mutates pointContainer\n   */\n  *quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue> {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n\n    const tracker = new ProgressTracker(height, 99);\n    for (let y = 0; y < height; y++) {\n      if (tracker.shouldNotify(y)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n      for (let x = 0, idx = y * width; x < width; x++, idx++) {\n        // Image pixel\n        const point = pointArray[idx];\n        // Reduced pixel\n        point.from(palette.getNearestColor(this._distance, point));\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { Point } from '../utils/point';\nimport { inRange0to255Rounded } from '../utils/arithmetic';\nimport { ImageQuantizerYieldValue } from './imageQuantizerYieldValue';\nimport { ProgressTracker } from '../utils/progressTracker';\n\n// TODO: is it the best name for this enum \"kernel\"?\nexport enum ErrorDiffusionArrayKernel {\n  FloydSteinberg = 0,\n  FalseFloydSteinberg,\n  Stucki,\n  Atkinson,\n  Jarvis,\n  Burkes,\n  Sierra,\n  TwoSierra,\n  SierraLite,\n}\n\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\nexport class ErrorDiffusionArray extends AbstractImageQuantizer {\n  private _minColorDistance: number;\n  private _serpentine: boolean;\n  private _kernel!: number[][];\n  /** true = GIMP, false = XNVIEW */\n  private _calculateErrorLikeGIMP: boolean;\n\n  private _distance: AbstractDistanceCalculator;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    kernel: ErrorDiffusionArrayKernel,\n    serpentine = true,\n    minimumColorDistanceToDither = 0,\n    calculateErrorLikeGIMP = false,\n  ) {\n    super();\n    this._setKernel(kernel);\n\n    this._distance = colorDistanceCalculator;\n    this._minColorDistance = minimumColorDistanceToDither;\n    this._serpentine = serpentine;\n    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\n  }\n\n  /**\n   * adapted from http://jsbin.com/iXofIji/2/edit by PAEz\n   * fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\n   * Mutates pointContainer\n   */\n  *quantize(\n    pointContainer: PointContainer,\n    palette: Palette,\n  ): IterableIterator<ImageQuantizerYieldValue> {\n    const pointArray = pointContainer.getPointArray();\n    const originalPoint = new Point();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorLines: number[][][] = [];\n\n    let dir = 1;\n    let maxErrorLines = 1;\n\n    // initial error lines (number is taken from dithering kernel)\n    for (const kernel of this._kernel) {\n      const kernelErrorLines = kernel[2] + 1;\n      if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\n    }\n    for (let i = 0; i < maxErrorLines; i++) {\n      this._fillErrorLine((errorLines[i] = []), width);\n    }\n\n    const tracker = new ProgressTracker(height, 99);\n    for (let y = 0; y < height; y++) {\n      if (tracker.shouldNotify(y)) {\n        yield {\n          progress: tracker.progress,\n        };\n      }\n\n      // always serpentine\n      if (this._serpentine) dir *= -1;\n\n      const lni = y * width;\n      const xStart = dir === 1 ? 0 : width - 1;\n      const xEnd = dir === 1 ? width : -1;\n\n      // cyclic shift with erasing\n      this._fillErrorLine(errorLines[0], width);\n      // TODO: why it is needed to cast types here?\n      errorLines.push(errorLines.shift() as number[][]);\n\n      const errorLine = errorLines[0];\n      for (\n        let x = xStart, idx = lni + xStart;\n        x !== xEnd;\n        x += dir, idx += dir\n      ) {\n        // Image pixel\n        const point = pointArray[idx];\n        // originalPoint = new Utils.Point(),\n        const error = errorLine[x];\n\n        originalPoint.from(point);\n\n        const correctedPoint = Point.createByRGBA(\n          inRange0to255Rounded(point.r + error[0]),\n          inRange0to255Rounded(point.g + error[1]),\n          inRange0to255Rounded(point.b + error[2]),\n          inRange0to255Rounded(point.a + error[3]),\n        );\n\n        // Reduced pixel\n        const palettePoint = palette.getNearestColor(\n          this._distance,\n          correctedPoint,\n        );\n        point.from(palettePoint);\n\n        // dithering strength\n        if (this._minColorDistance) {\n          const dist = this._distance.calculateNormalized(\n            originalPoint,\n            palettePoint,\n          );\n          if (dist < this._minColorDistance) continue;\n        }\n\n        // Component distance\n        let er;\n        let eg;\n        let eb;\n        let ea;\n        if (this._calculateErrorLikeGIMP) {\n          er = correctedPoint.r - palettePoint.r;\n          eg = correctedPoint.g - palettePoint.g;\n          eb = correctedPoint.b - palettePoint.b;\n          ea = correctedPoint.a - palettePoint.a;\n        } else {\n          er = originalPoint.r - palettePoint.r;\n          eg = originalPoint.g - palettePoint.g;\n          eb = originalPoint.b - palettePoint.b;\n          ea = originalPoint.a - palettePoint.a;\n        }\n\n        const dStart = dir === 1 ? 0 : this._kernel.length - 1;\n        const dEnd = dir === 1 ? this._kernel.length : -1;\n\n        for (let i = dStart; i !== dEnd; i += dir) {\n          const x1 = this._kernel[i][1] * dir;\n          const y1 = this._kernel[i][2];\n\n          if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\n            const d = this._kernel[i][0];\n            const e = errorLines[y1][x1 + x];\n\n            e[0] += er * d;\n            e[1] += eg * d;\n            e[2] += eb * d;\n            e[3] += ea * d;\n          }\n        }\n      }\n    }\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n\n  private _fillErrorLine(errorLine: number[][], width: number) {\n    // shrink\n    if (errorLine.length > width) {\n      errorLine.length = width;\n    }\n\n    // reuse existing arrays\n    const l = errorLine.length;\n    for (let i = 0; i < l; i++) {\n      const error = errorLine[i];\n      error[0] = error[1] = error[2] = error[3] = 0;\n    }\n\n    // create missing arrays\n    for (let i = l; i < width; i++) {\n      errorLine[i] = [0.0, 0.0, 0.0, 0.0];\n    }\n  }\n\n  private _setKernel(kernel: ErrorDiffusionArrayKernel) {\n    switch (kernel) {\n      case ErrorDiffusionArrayKernel.FloydSteinberg:\n        this._kernel = [\n          [7 / 16, 1, 0],\n          [3 / 16, -1, 1],\n          [5 / 16, 0, 1],\n          [1 / 16, 1, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\n        this._kernel = [\n          [3 / 8, 1, 0],\n          [3 / 8, 0, 1],\n          [2 / 8, 1, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Stucki:\n        this._kernel = [\n          [8 / 42, 1, 0],\n          [4 / 42, 2, 0],\n          [2 / 42, -2, 1],\n          [4 / 42, -1, 1],\n          [8 / 42, 0, 1],\n          [4 / 42, 1, 1],\n          [2 / 42, 2, 1],\n          [1 / 42, -2, 2],\n          [2 / 42, -1, 2],\n          [4 / 42, 0, 2],\n          [2 / 42, 1, 2],\n          [1 / 42, 2, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Atkinson:\n        this._kernel = [\n          [1 / 8, 1, 0],\n          [1 / 8, 2, 0],\n          [1 / 8, -1, 1],\n          [1 / 8, 0, 1],\n          [1 / 8, 1, 1],\n          [1 / 8, 0, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Jarvis:\n        this._kernel = [\n          // Jarvis, Judice, and Ninke / JJN?\n          [7 / 48, 1, 0],\n          [5 / 48, 2, 0],\n          [3 / 48, -2, 1],\n          [5 / 48, -1, 1],\n          [7 / 48, 0, 1],\n          [5 / 48, 1, 1],\n          [3 / 48, 2, 1],\n          [1 / 48, -2, 2],\n          [3 / 48, -1, 2],\n          [5 / 48, 0, 2],\n          [3 / 48, 1, 2],\n          [1 / 48, 2, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Burkes:\n        this._kernel = [\n          [8 / 32, 1, 0],\n          [4 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [8 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.Sierra:\n        this._kernel = [\n          [5 / 32, 1, 0],\n          [3 / 32, 2, 0],\n          [2 / 32, -2, 1],\n          [4 / 32, -1, 1],\n          [5 / 32, 0, 1],\n          [4 / 32, 1, 1],\n          [2 / 32, 2, 1],\n          [2 / 32, -1, 2],\n          [3 / 32, 0, 2],\n          [2 / 32, 1, 2],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.TwoSierra:\n        this._kernel = [\n          [4 / 16, 1, 0],\n          [3 / 16, 2, 0],\n          [1 / 16, -2, 1],\n          [2 / 16, -1, 1],\n          [3 / 16, 0, 1],\n          [2 / 16, 1, 1],\n          [1 / 16, 2, 1],\n        ];\n        break;\n\n      case ErrorDiffusionArrayKernel.SierraLite:\n        this._kernel = [\n          [2 / 4, 1, 0],\n          [1 / 4, -1, 1],\n          [1 / 4, 0, 1],\n        ];\n        break;\n\n      default:\n        throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);\n    }\n  }\n}\n","import { ProgressTracker } from '../../utils/progressTracker';\nimport { ImageQuantizerYieldValue } from '../imageQuantizerYieldValue';\n\nenum Direction {\n  NONE = 0,\n  UP,\n  LEFT,\n  RIGHT,\n  DOWN,\n}\n\ninterface Data {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  level: number;\n  index: number;\n  tracker: ProgressTracker;\n  callback(x: number, y: number): void;\n}\n\nexport function* hilbertCurve(\n  width: number,\n  height: number,\n  callback: (x: number, y: number) => void,\n) {\n  const maxBound = Math.max(width, height);\n  const level = Math.floor(Math.log(maxBound) / Math.log(2) + 1);\n  const tracker = new ProgressTracker(width * height, 99);\n  const data = {\n    width,\n    height,\n    level,\n    callback,\n    tracker,\n    index: 0,\n    x: 0,\n    y: 0,\n  };\n  yield* walkHilbert(data, Direction.UP);\n  visit(data, Direction.NONE);\n}\n\nfunction* walkHilbert(\n  data: Data,\n  direction: Direction,\n): IterableIterator<ImageQuantizerYieldValue> {\n  if (data.level < 1) return;\n\n  if (data.tracker.shouldNotify(data.index)) {\n    yield { progress: data.tracker.progress };\n  }\n  data.level--;\n  switch (direction) {\n    case Direction.LEFT:\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.DOWN);\n      break;\n\n    case Direction.RIGHT:\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.UP);\n      break;\n\n    case Direction.UP:\n      yield* walkHilbert(data, Direction.LEFT);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.RIGHT);\n      yield* walkHilbert(data, Direction.UP);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.RIGHT);\n      break;\n\n    case Direction.DOWN:\n      yield* walkHilbert(data, Direction.RIGHT);\n      visit(data, Direction.UP);\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.LEFT);\n      yield* walkHilbert(data, Direction.DOWN);\n      visit(data, Direction.DOWN);\n      yield* walkHilbert(data, Direction.LEFT);\n      break;\n\n    default:\n      break;\n  }\n  data.level++;\n}\n\nfunction visit(data: Data, direction: Direction) {\n  if (\n    data.x >= 0 &&\n    data.x < data.width &&\n    data.y >= 0 &&\n    data.y < data.height\n  ) {\n    data.callback(data.x, data.y);\n    data.index++;\n  }\n  switch (direction) {\n    case Direction.LEFT:\n      data.x--;\n      break;\n    case Direction.RIGHT:\n      data.x++;\n      break;\n    case Direction.UP:\n      data.y--;\n      break;\n    case Direction.DOWN:\n      data.y++;\n      break;\n  }\n}\n","/**\n * @preserve\n * MIT License\n *\n * Copyright 2015-2018 Igor Bezkrovnyi\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n * riemersma.ts - part of Image Quantization Library\n */\nimport { AbstractImageQuantizer } from './imageQuantizer';\nimport { hilbertCurve } from './spaceFillingCurves/hilbertCurve';\nimport { AbstractDistanceCalculator } from '../distance/distanceCalculator';\nimport { PointContainer } from '../utils/pointContainer';\nimport { Palette } from '../utils/palette';\nimport { Point } from '../utils/point';\nimport { inRange0to255Rounded } from '../utils/arithmetic';\n\nexport class ErrorDiffusionRiemersma extends AbstractImageQuantizer {\n  private _distance: AbstractDistanceCalculator;\n  private _weights: number[];\n  private _errorQueueSize: number;\n\n  constructor(\n    colorDistanceCalculator: AbstractDistanceCalculator,\n    errorQueueSize = 16,\n    errorPropagation = 1,\n  ) {\n    super();\n    this._distance = colorDistanceCalculator;\n    this._errorQueueSize = errorQueueSize;\n    this._weights = ErrorDiffusionRiemersma._createWeights(\n      errorPropagation,\n      errorQueueSize,\n    );\n  }\n\n  /**\n   * Mutates pointContainer\n   */\n  *quantize(pointContainer: PointContainer, palette: Palette) {\n    const pointArray = pointContainer.getPointArray();\n    const width = pointContainer.getWidth();\n    const height = pointContainer.getHeight();\n    const errorQueue: Array<{\n      r: number;\n      g: number;\n      b: number;\n      a: number;\n    }> = [];\n\n    let head = 0;\n\n    for (let i = 0; i < this._errorQueueSize; i++) {\n      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };\n    }\n\n    yield* hilbertCurve(width, height, (x, y) => {\n      const p = pointArray[x + y * width];\n      let { r, g, b, a } = p;\n      for (let i = 0; i < this._errorQueueSize; i++) {\n        const weight = this._weights[i];\n        const e = errorQueue[(i + head) % this._errorQueueSize];\n\n        r += e.r * weight;\n        g += e.g * weight;\n        b += e.b * weight;\n        a += e.a * weight;\n      }\n\n      const correctedPoint = Point.createByRGBA(\n        inRange0to255Rounded(r),\n        inRange0to255Rounded(g),\n        inRange0to255Rounded(b),\n        inRange0to255Rounded(a),\n      );\n\n      const quantizedPoint = palette.getNearestColor(\n        this._distance,\n        correctedPoint,\n      );\n\n      // update head and calculate tail\n      head = (head + 1) % this._errorQueueSize;\n      const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\n\n      // update error with new value\n      errorQueue[tail].r = p.r - quantizedPoint.r;\n      errorQueue[tail].g = p.g - quantizedPoint.g;\n      errorQueue[tail].b = p.b - quantizedPoint.b;\n      errorQueue[tail].a = p.a - quantizedPoint.a;\n\n      // update point\n      p.from(quantizedPoint);\n    });\n\n    yield {\n      pointContainer,\n      progress: 100,\n    };\n  }\n\n  private static _createWeights(\n    errorPropagation: number,\n    errorQueueSize: number,\n  ) {\n    const weights = [];\n\n    const multiplier = Math.exp(\n      Math.log(errorQueueSize) / (errorQueueSize - 1),\n    );\n    for (let i = 0, next = 1; i < errorQueueSize; i++) {\n      weights[i] = (((next + 0.5) | 0) / errorQueueSize) * errorPropagation;\n      next *= multiplier;\n    }\n\n    return weights;\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nexport { ssim } from './ssim';\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * ssim.ts - part of Image Quantization Library\n */\nimport { PointContainer } from '../utils/pointContainer';\nimport { Y } from '../constants/bt709';\n\n// based on https://github.com/rhys-e/structural-similarity\n// http://en.wikipedia.org/wiki/Structural_similarity\nconst K1 = 0.01;\nconst K2 = 0.03;\n\nexport function ssim(image1: PointContainer, image2: PointContainer) {\n  if (\n    image1.getHeight() !== image2.getHeight() ||\n    image1.getWidth() !== image2.getWidth()\n  ) {\n    throw new Error('Images have different sizes!');\n  }\n\n  const bitsPerComponent = 8;\n  const L = (1 << bitsPerComponent) - 1;\n  const c1 = (K1 * L) ** 2;\n  const c2 = (K2 * L) ** 2;\n\n  let numWindows = 0;\n  let mssim = 0.0;\n\n  // calculate ssim for each window\n  iterate(\n    image1,\n    image2,\n    (lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {\n      // calculate variance and covariance\n      let sigxy = 0.0;\n      let sigsqx = 0.0;\n      let sigsqy = 0.0;\n\n      for (let i = 0; i < lumaValues1.length; i++) {\n        sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2;\n        sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2;\n\n        sigxy +=\n          (lumaValues1[i] - averageLumaValue1) *\n          (lumaValues2[i] - averageLumaValue2);\n      }\n\n      const numPixelsInWin = lumaValues1.length - 1;\n      sigsqx /= numPixelsInWin;\n      sigsqy /= numPixelsInWin;\n      sigxy /= numPixelsInWin;\n\n      // perform ssim calculation on window\n      const numerator =\n        (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2);\n      const denominator =\n        (averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) *\n        (sigsqx + sigsqy + c2);\n      const ssim = numerator / denominator;\n\n      mssim += ssim;\n      numWindows++;\n    },\n  );\n  return mssim / numWindows;\n}\n\nfunction iterate(\n  image1: PointContainer,\n  image2: PointContainer,\n  callback: (\n    lumaValues1: number[],\n    lumaValues2: number[],\n    averageLumaValue1: number,\n    averageLumaValue2: number,\n  ) => void,\n) {\n  const windowSize = 8;\n  const width = image1.getWidth();\n  const height = image1.getHeight();\n\n  for (let y = 0; y < height; y += windowSize) {\n    for (let x = 0; x < width; x += windowSize) {\n      // avoid out-of-width/height\n      const windowWidth = Math.min(windowSize, width - x);\n      const windowHeight = Math.min(windowSize, height - y);\n\n      const lumaValues1 = calculateLumaValuesForWindow(\n        image1,\n        x,\n        y,\n        windowWidth,\n        windowHeight,\n      );\n      const lumaValues2 = calculateLumaValuesForWindow(\n        image2,\n        x,\n        y,\n        windowWidth,\n        windowHeight,\n      );\n      const averageLuma1 = calculateAverageLuma(lumaValues1);\n      const averageLuma2 = calculateAverageLuma(lumaValues2);\n\n      callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\n    }\n  }\n}\n\nfunction calculateLumaValuesForWindow(\n  image: PointContainer,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) {\n  const pointArray = image.getPointArray();\n  const lumaValues = [];\n\n  let counter = 0;\n\n  for (let j = y; j < y + height; j++) {\n    const offset = j * image.getWidth();\n    for (let i = x; i < x + width; i++) {\n      const point = pointArray[offset + i];\n      lumaValues[counter] =\n        point.r * Y.RED + point.g * Y.GREEN + point.b * Y.BLUE;\n      counter++;\n    }\n  }\n\n  return lumaValues;\n}\n\nfunction calculateAverageLuma(lumaValues: number[]) {\n  let sumLuma = 0.0;\n  for (const luma of lumaValues) {\n    sumLuma += luma;\n  }\n\n  return sumLuma / lumaValues.length;\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * helper.ts - part of Image Quantization Library\n */\nimport * as distance from './distance';\nimport * as image from './image';\nimport * as palette from './palette';\nimport { AbstractDistanceCalculator } from './distance/distanceCalculator';\nimport { PointContainer } from './utils/pointContainer';\nimport { Palette } from './utils/palette';\n\nconst setImmediateImpl =\n  typeof setImmediate === 'function'\n    ? setImmediate\n    : typeof process !== 'undefined' && typeof process?.nextTick === 'function'\n    ? (callback: () => void) => process.nextTick(callback)\n    : (callback: () => void) => setTimeout(callback, 0);\n\nexport type ColorDistanceFormula =\n  | 'cie94-textiles'\n  | 'cie94-graphic-arts'\n  | 'ciede2000'\n  | 'color-metric'\n  | 'euclidean'\n  | 'euclidean-bt709-noalpha'\n  | 'euclidean-bt709'\n  | 'manhattan'\n  | 'manhattan-bt709'\n  | 'manhattan-nommyde'\n  | 'pngquant';\n\nexport type PaletteQuantization =\n  | 'neuquant'\n  | 'neuquant-float'\n  | 'rgbquant'\n  | 'wuquant';\n\nexport type ImageQuantization =\n  | 'nearest'\n  | 'riemersma'\n  | 'floyd-steinberg'\n  | 'false-floyd-steinberg'\n  | 'stucki'\n  | 'atkinson'\n  | 'jarvis'\n  | 'burkes'\n  | 'sierra'\n  | 'two-sierra'\n  | 'sierra-lite';\n\nexport interface ProgressOptions {\n  onProgress?: (progress: number) => void;\n}\n\nexport interface ApplyPaletteOptions {\n  colorDistanceFormula?: ColorDistanceFormula;\n  imageQuantization?: ImageQuantization;\n}\n\nexport interface BuildPaletteOptions {\n  colorDistanceFormula?: ColorDistanceFormula;\n  paletteQuantization?: PaletteQuantization;\n  colors?: number;\n}\n\nexport function buildPaletteSync(\n  images: PointContainer[],\n  {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n  }: BuildPaletteOptions = {},\n) {\n  const distanceCalculator =\n    colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const paletteQuantizer = paletteQuantizationToPaletteQuantizer(\n    distanceCalculator,\n    paletteQuantization,\n    colors,\n  );\n  images.forEach((image) => paletteQuantizer.sample(image));\n  return paletteQuantizer.quantizeSync();\n}\n\nexport async function buildPalette(\n  images: PointContainer[],\n  {\n    colorDistanceFormula,\n    paletteQuantization,\n    colors,\n    onProgress,\n  }: BuildPaletteOptions & ProgressOptions = {},\n) {\n  return new Promise<Palette>((resolve, reject) => {\n    const distanceCalculator =\n      colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(\n      distanceCalculator,\n      paletteQuantization,\n      colors,\n    );\n    images.forEach((image) => paletteQuantizer.sample(image));\n\n    let palette: Palette;\n    const iterator = paletteQuantizer.quantize();\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(palette);\n        } else {\n          if (result.value.palette) palette = result.value.palette;\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\n\nexport function applyPaletteSync(\n  image: PointContainer,\n  palette: Palette,\n  { colorDistanceFormula, imageQuantization }: ApplyPaletteOptions = {},\n) {\n  const distanceCalculator =\n    colorDistanceFormulaToColorDistance(colorDistanceFormula);\n  const imageQuantizer = imageQuantizationToImageQuantizer(\n    distanceCalculator,\n    imageQuantization,\n  );\n  return imageQuantizer.quantizeSync(image, palette);\n}\n\nexport async function applyPalette(\n  image: PointContainer,\n  palette: Palette,\n  {\n    colorDistanceFormula,\n    imageQuantization,\n    onProgress,\n  }: ApplyPaletteOptions & ProgressOptions = {},\n) {\n  return new Promise<PointContainer>((resolve, reject) => {\n    const distanceCalculator =\n      colorDistanceFormulaToColorDistance(colorDistanceFormula);\n    const imageQuantizer = imageQuantizationToImageQuantizer(\n      distanceCalculator,\n      imageQuantization,\n    );\n\n    let outPointContainer: PointContainer;\n    const iterator = imageQuantizer.quantize(image, palette);\n    const next = () => {\n      try {\n        const result = iterator.next();\n        if (result.done) {\n          resolve(outPointContainer);\n        } else {\n          if (result.value.pointContainer) {\n            outPointContainer = result.value.pointContainer;\n          }\n          if (onProgress) onProgress(result.value.progress);\n          setImmediateImpl(next);\n        }\n      } catch (error) {\n        reject(error);\n      }\n    };\n    setImmediateImpl(next);\n  });\n}\n\nfunction colorDistanceFormulaToColorDistance(\n  colorDistanceFormula: ColorDistanceFormula = 'euclidean-bt709',\n) {\n  switch (colorDistanceFormula) {\n    case 'cie94-graphic-arts':\n      return new distance.CIE94GraphicArts();\n    case 'cie94-textiles':\n      return new distance.CIE94Textiles();\n    case 'ciede2000':\n      return new distance.CIEDE2000();\n    case 'color-metric':\n      return new distance.CMetric();\n    case 'euclidean':\n      return new distance.Euclidean();\n    case 'euclidean-bt709':\n      return new distance.EuclideanBT709();\n    case 'euclidean-bt709-noalpha':\n      return new distance.EuclideanBT709NoAlpha();\n    case 'manhattan':\n      return new distance.Manhattan();\n    case 'manhattan-bt709':\n      return new distance.ManhattanBT709();\n    case 'manhattan-nommyde':\n      return new distance.ManhattanNommyde();\n    case 'pngquant':\n      return new distance.PNGQuant();\n    default:\n      throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);\n  }\n}\n\nfunction imageQuantizationToImageQuantizer(\n  distanceCalculator: AbstractDistanceCalculator,\n  imageQuantization: ImageQuantization = 'floyd-steinberg',\n) {\n  switch (imageQuantization) {\n    case 'nearest':\n      return new image.NearestColor(distanceCalculator);\n    case 'riemersma':\n      return new image.ErrorDiffusionRiemersma(distanceCalculator);\n    case 'floyd-steinberg':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.FloydSteinberg,\n      );\n    case 'false-floyd-steinberg':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.FalseFloydSteinberg,\n      );\n    case 'stucki':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Stucki,\n      );\n    case 'atkinson':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Atkinson,\n      );\n    case 'jarvis':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Jarvis,\n      );\n    case 'burkes':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Burkes,\n      );\n    case 'sierra':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.Sierra,\n      );\n    case 'two-sierra':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.TwoSierra,\n      );\n    case 'sierra-lite':\n      return new image.ErrorDiffusionArray(\n        distanceCalculator,\n        image.ErrorDiffusionArrayKernel.SierraLite,\n      );\n    default:\n      throw new Error(`Unknown imageQuantization ${imageQuantization}`);\n  }\n}\n\nfunction paletteQuantizationToPaletteQuantizer(\n  distanceCalculator: AbstractDistanceCalculator,\n  paletteQuantization: PaletteQuantization = 'wuquant',\n  colors = 256,\n) {\n  switch (paletteQuantization) {\n    case 'neuquant':\n      return new palette.NeuQuant(distanceCalculator, colors);\n    case 'rgbquant':\n      return new palette.RGBQuant(distanceCalculator, colors);\n    case 'wuquant':\n      return new palette.WuQuant(distanceCalculator, colors);\n    case 'neuquant-float':\n      return new palette.NeuQuantFloat(distanceCalculator, colors);\n    default:\n      throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);\n  }\n}\n","/**\n * @preserve\n * Copyright 2015-2018 Igor Bezkrovnyi\n * All rights reserved. (MIT Licensed)\n *\n * iq.ts - Image Quantization Library\n */\nimport * as constants from './constants';\nimport * as conversion from './conversion';\nimport * as distance from './distance';\nimport * as palette from './palette';\nimport * as image from './image';\nimport * as quality from './quality';\nimport * as utils from './utils';\n\nexport {\n  buildPalette,\n  buildPaletteSync,\n  applyPalette,\n  applyPaletteSync,\n} from './basicAPI';\n\nexport type {\n  ImageQuantization,\n  PaletteQuantization,\n  ColorDistanceFormula,\n} from './basicAPI';\n\nexport { constants, conversion, distance, palette, image, quality, utils };\n"]},"metadata":{},"sourceType":"module"}