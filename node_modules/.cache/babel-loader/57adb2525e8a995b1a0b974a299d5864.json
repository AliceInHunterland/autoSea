{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n\nvar _resize = _interopRequireDefault(require(\"./modules/resize\"));\n\nvar _resize2 = _interopRequireDefault(require(\"./modules/resize2\"));\n\nvar _default = function _default() {\n  return {\n    constants: {\n      RESIZE_NEAREST_NEIGHBOR: 'nearestNeighbor',\n      RESIZE_BILINEAR: 'bilinearInterpolation',\n      RESIZE_BICUBIC: 'bicubicInterpolation',\n      RESIZE_HERMITE: 'hermiteInterpolation',\n      RESIZE_BEZIER: 'bezierInterpolation'\n    },\n    \"class\": {\n      /**\n       * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n       * @param {number} w the width to resize the image to (or Jimp.AUTO)\n       * @param {number} h the height to resize the image to (or Jimp.AUTO)\n       * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n       * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n       * @returns {Jimp} this for chaining of methods\n       */\n      resize: function resize(w, h, mode, cb) {\n        if (typeof w !== 'number' || typeof h !== 'number') {\n          return _utils.throwError.call(this, 'w and h must be numbers', cb);\n        }\n\n        if (typeof mode === 'function' && typeof cb === 'undefined') {\n          cb = mode;\n          mode = null;\n        }\n\n        if (w === this.constructor.AUTO && h === this.constructor.AUTO) {\n          return _utils.throwError.call(this, 'w and h cannot both be set to auto', cb);\n        }\n\n        if (w === this.constructor.AUTO) {\n          w = this.bitmap.width * (h / this.bitmap.height);\n        }\n\n        if (h === this.constructor.AUTO) {\n          h = this.bitmap.height * (w / this.bitmap.width);\n        }\n\n        if (w < 0 || h < 0) {\n          return _utils.throwError.call(this, 'w and h must be positive numbers', cb);\n        } // round inputs\n\n\n        w = Math.round(w);\n        h = Math.round(h);\n\n        if (typeof _resize2[\"default\"][mode] === 'function') {\n          var dst = {\n            data: Buffer.alloc(w * h * 4),\n            width: w,\n            height: h\n          };\n\n          _resize2[\"default\"][mode](this.bitmap, dst);\n\n          this.bitmap = dst;\n        } else {\n          var image = this;\n          var resize = new _resize[\"default\"](this.bitmap.width, this.bitmap.height, w, h, true, true, function (buffer) {\n            image.bitmap.data = Buffer.from(buffer);\n            image.bitmap.width = w;\n            image.bitmap.height = h;\n          });\n          resize.resize(this.bitmap.data);\n        }\n\n        if ((0, _utils.isNodePattern)(cb)) {\n          cb.call(this, null, this);\n        }\n\n        return this;\n      }\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["constants","RESIZE_NEAREST_NEIGHBOR","RESIZE_BILINEAR","RESIZE_BICUBIC","RESIZE_HERMITE","RESIZE_BEZIER","resize","throwError","cb","mode","w","h","Math","Resize2","dst","data","Buffer","width","height","image","Resize"],"mappings":"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","sourcesContent":["import { throwError, isNodePattern } from '@jimp/utils';\n\nimport Resize from './modules/resize';\nimport Resize2 from './modules/resize2';\n\nexport default () => ({\n  constants: {\n    RESIZE_NEAREST_NEIGHBOR: 'nearestNeighbor',\n    RESIZE_BILINEAR: 'bilinearInterpolation',\n    RESIZE_BICUBIC: 'bicubicInterpolation',\n    RESIZE_HERMITE: 'hermiteInterpolation',\n    RESIZE_BEZIER: 'bezierInterpolation'\n  },\n\n  class: {\n    /**\n     * Resizes the image to a set width and height using a 2-pass bilinear algorithm\n     * @param {number} w the width to resize the image to (or Jimp.AUTO)\n     * @param {number} h the height to resize the image to (or Jimp.AUTO)\n     * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)\n     * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n     * @returns {Jimp} this for chaining of methods\n     */\n    resize(w, h, mode, cb) {\n      if (typeof w !== 'number' || typeof h !== 'number') {\n        return throwError.call(this, 'w and h must be numbers', cb);\n      }\n\n      if (typeof mode === 'function' && typeof cb === 'undefined') {\n        cb = mode;\n        mode = null;\n      }\n\n      if (w === this.constructor.AUTO && h === this.constructor.AUTO) {\n        return throwError.call(this, 'w and h cannot both be set to auto', cb);\n      }\n\n      if (w === this.constructor.AUTO) {\n        w = this.bitmap.width * (h / this.bitmap.height);\n      }\n\n      if (h === this.constructor.AUTO) {\n        h = this.bitmap.height * (w / this.bitmap.width);\n      }\n\n      if (w < 0 || h < 0) {\n        return throwError.call(this, 'w and h must be positive numbers', cb);\n      }\n\n      // round inputs\n      w = Math.round(w);\n      h = Math.round(h);\n\n      if (typeof Resize2[mode] === 'function') {\n        const dst = {\n          data: Buffer.alloc(w * h * 4),\n          width: w,\n          height: h\n        };\n        Resize2[mode](this.bitmap, dst);\n        this.bitmap = dst;\n      } else {\n        const image = this;\n        const resize = new Resize(\n          this.bitmap.width,\n          this.bitmap.height,\n          w,\n          h,\n          true,\n          true,\n          buffer => {\n            image.bitmap.data = Buffer.from(buffer);\n            image.bitmap.width = w;\n            image.bitmap.height = h;\n          }\n        );\n        resize.resize(this.bitmap.data);\n      }\n\n      if (isNodePattern(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  }\n});\n"]},"metadata":{},"sourceType":"script"}