{"ast":null,"code":"var _toConsumableArray = require(\"/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _regeneratorRuntime = require(\"/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _objectSpread = require(\"/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\n\nvar _objectWithoutProperties = require(\"/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\n\nvar _excluded = [\"log\", \"logger\", \"progress\"];\n\nvar _require = require('./config'),\n    defaultArgs = _require.defaultArgs,\n    baseOptions = _require.baseOptions;\n\nvar _require2 = require('./utils/log'),\n    setLogging = _require2.setLogging,\n    setCustomLogger = _require2.setCustomLogger,\n    log = _require2.log;\n\nvar parseProgress = require('./utils/parseProgress');\n\nvar parseArgs = require('./utils/parseArgs');\n\nvar _require3 = require('./node'),\n    defaultOptions = _require3.defaultOptions,\n    getCreateFFmpegCore = _require3.getCreateFFmpegCore;\n\nvar _require4 = require('../package.json'),\n    version = _require4.version;\n\nvar NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = function () {\n  var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _baseOptions$defaultO = _objectSpread(_objectSpread(_objectSpread({}, baseOptions), defaultOptions), _options),\n      logging = _baseOptions$defaultO.log,\n      logger = _baseOptions$defaultO.logger,\n      optProgress = _baseOptions$defaultO.progress,\n      options = _objectWithoutProperties(_baseOptions$defaultO, _excluded);\n\n  var Core = null;\n  var ffmpeg = null;\n  var runResolve = null;\n  var running = false;\n  var progress = optProgress;\n\n  var detectCompletion = function detectCompletion(message) {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n\n  var parseMessage = function parseMessage(_ref) {\n    var type = _ref.type,\n        message = _ref.message;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  var load = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n      var _yield$getCreateFFmpe, createFFmpegCore, corePath, workerPath, wasmPath;\n\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              log('info', 'load ffmpeg-core');\n\n              if (!(Core === null)) {\n                _context.next = 17;\n                break;\n              }\n\n              log('info', 'loading ffmpeg-core');\n              /*\n               * In node environment, all paths are undefined as there\n               * is no need to set them.\n               */\n\n              _context.next = 5;\n              return getCreateFFmpegCore(options);\n\n            case 5:\n              _yield$getCreateFFmpe = _context.sent;\n              createFFmpegCore = _yield$getCreateFFmpe.createFFmpegCore;\n              corePath = _yield$getCreateFFmpe.corePath;\n              workerPath = _yield$getCreateFFmpe.workerPath;\n              wasmPath = _yield$getCreateFFmpe.wasmPath;\n              _context.next = 12;\n              return createFFmpegCore({\n                /*\n                 * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n                 * as there is no document.currentScript in the context of content_scripts\n                 */\n                mainScriptUrlOrBlob: corePath,\n                printErr: function printErr(message) {\n                  return parseMessage({\n                    type: 'fferr',\n                    message: message\n                  });\n                },\n                print: function print(message) {\n                  return parseMessage({\n                    type: 'ffout',\n                    message: message\n                  });\n                },\n\n                /*\n                 * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n                 * It is critical for browser environment and we override both wasm and worker paths\n                 * as we are using blob URL instead of original URL to avoid cross origin issues.\n                 */\n                locateFile: function locateFile(path, prefix) {\n                  if (typeof window !== 'undefined') {\n                    if (typeof wasmPath !== 'undefined' && path.endsWith('ffmpeg-core.wasm')) {\n                      return wasmPath;\n                    }\n\n                    if (typeof workerPath !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n                      return workerPath;\n                    }\n                  }\n\n                  return prefix + path;\n                }\n              });\n\n            case 12:\n              Core = _context.sent;\n              ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n              log('info', 'ffmpeg-core loaded');\n              _context.next = 18;\n              break;\n\n            case 17:\n              throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function load() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  var isLoaded = function isLoaded() {\n    return Core !== null;\n  };\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  var run = function run() {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    log('info', \"run ffmpeg command: \".concat(_args.join(' ')));\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(function (resolve) {\n        var args = [].concat(_toConsumableArray(defaultArgs), _args).filter(function (s) {\n          return s.length !== 0;\n        });\n        runResolve = resolve;\n        ffmpeg.apply(void 0, _toConsumableArray(parseArgs(Core, args)));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  var FS = function FS(method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    log('info', \"run FS.\".concat(method, \" \").concat(args.map(function (arg) {\n      return typeof arg === 'string' ? arg : \"<\".concat(arg.length, \" bytes binary file>\");\n    }).join(' ')));\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      var ret = null;\n\n      try {\n        var _Core$FS;\n\n        ret = (_Core$FS = Core.FS)[method].apply(_Core$FS, args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(\"ffmpeg.FS('readdir', '\".concat(args[0], \"') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')\"));\n        } else if (method === 'readFile') {\n          throw Error(\"ffmpeg.FS('readFile', '\".concat(args[0], \"') error. Check if the path exists\"));\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n\n\n  var exit = function exit() {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  var setProgress = function setProgress(_progress) {\n    progress = _progress;\n  };\n\n  var setLogger = function setLogger(_logger) {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n  log('info', \"use ffmpeg.wasm v\".concat(version));\n  return {\n    setProgress: setProgress,\n    setLogger: setLogger,\n    setLogging: setLogging,\n    load: load,\n    isLoaded: isLoaded,\n    run: run,\n    exit: exit,\n    FS: FS\n  };\n};","map":{"version":3,"names":["require","defaultArgs","baseOptions","setLogging","setCustomLogger","log","parseProgress","parseArgs","defaultOptions","getCreateFFmpegCore","version","NO_LOAD","Error","module","exports","_options","logging","logger","optProgress","progress","options","Core","ffmpeg","runResolve","running","detectCompletion","message","parseMessage","type","load","createFFmpegCore","corePath","workerPath","wasmPath","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","isLoaded","run","_args","join","Promise","resolve","args","filter","s","length","FS","method","map","arg","ret","e","exit","setProgress","_progress","setLogger","_logger"],"sources":["/Users/ekaterinapavlova/PycharmProjects/onix/ffmpegwasm.github.io/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}