{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _utils = require(\"@jimp/utils\");\n/**\n * Creates a circle out of an image.\n * @param {function(Error, Jimp)} options (optional) radius, x, y\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\n\n\nvar _default = function _default() {\n  return {\n    circle: function circle() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var cb = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (typeof options === 'function') {\n        cb = options;\n        options = {};\n      }\n\n      var radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;\n      var center = {\n        x: typeof options.x === 'number' ? options.x : this.bitmap.width / 2,\n        y: typeof options.y === 'number' ? options.y : this.bitmap.height / 2\n      };\n      this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n        var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));\n\n        if (radius - curR <= 0.0) {\n          this.bitmap.data[idx + 3] = 0;\n        } else if (radius - curR < 1.0) {\n          this.bitmap.data[idx + 3] = 255 * (radius - curR);\n        }\n      });\n\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this);\n      }\n\n      return this;\n    }\n  };\n};\n\nexports[\"default\"] = _default;","map":{"version":3,"sources":["../src/index.js"],"names":["circle","options","cb","radius","center","x","y","curR","Math","idx"],"mappings":";;;;;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;;;;;;;eAMe,SAAA,QAAA,GAAA;EAAA,OAAO;IACpBA,MADoB,EAAA,SAAA,MAAA,GACK;MAAA,IAAlBC,OAAkB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAR,EAAQ;MAAA,IAAJC,EAAI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;;MACvB,IAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;QACjCA,EAAE,GAAFA,OAAAA;QACAD,OAAO,GAAPA,EAAAA;MACD;;MAED,IAAME,MAAM,GACVF,OAAO,CAAPA,MAAAA,IACA,CAAC,KAAA,MAAA,CAAA,KAAA,GAAoB,KAAA,MAAA,CAApB,MAAA,GACG,KAAA,MAAA,CADH,MAAA,GAEG,KAAA,MAAA,CAFJ,KAAA,IAFF,CAAA;MAMA,IAAMG,MAAM,GAAG;QACbC,CAAC,EAAE,OAAOJ,OAAO,CAAd,CAAA,KAAA,QAAA,GAAgCA,OAAO,CAAvC,CAAA,GAA4C,KAAA,MAAA,CAAA,KAAA,GADlC,CAAA;QAEbK,CAAC,EAAE,OAAOL,OAAO,CAAd,CAAA,KAAA,QAAA,GAAgCA,OAAO,CAAvC,CAAA,GAA4C,KAAA,MAAA,CAAA,MAAA,GAAqB;MAFvD,CAAf;MAKA,KAAA,SAAA,CAAA,CAAA,EAAA,CAAA,EAAqB,KAAA,MAAA,CAArB,KAAA,EAAwC,KAAA,MAAA,CAAxC,MAAA,EAA4D,UAAA,CAAA,EAAA,CAAA,EAAA,GAAA,EAI1D;QACA,IAAMM,IAAI,GAAGC,IAAI,CAAJA,IAAAA,CACXA,IAAI,CAAJA,GAAAA,CAASH,CAAC,GAAGD,MAAM,CAAnBI,CAAAA,EAAAA,CAAAA,IAA4BA,IAAI,CAAJA,GAAAA,CAASF,CAAC,GAAGF,MAAM,CAAnBI,CAAAA,EAD9B,CAC8BA,CADjBA,CAAb;;QAIA,IAAIL,MAAM,GAANA,IAAAA,IAAJ,GAAA,EAA0B;UACxB,KAAA,MAAA,CAAA,IAAA,CAAiBM,GAAG,GAApB,CAAA,IAAA,CAAA;QADF,CAAA,MAEO,IAAIN,MAAM,GAANA,IAAAA,GAAJ,GAAA,EAAyB;UAC9B,KAAA,MAAA,CAAA,IAAA,CAAiBM,GAAG,GAApB,CAAA,IAA4B,OAAON,MAAM,GAAzC,IAA4B,CAA5B;QACD;MAbH,CAAA;;MAgBA,IAAI,CAAA,GAAA,MAAA,CAAA,aAAA,EAAJ,EAAI,CAAJ,EAAuB;QACrBD,EAAE,CAAFA,IAAAA,CAAAA,IAAAA,EAAAA,IAAAA,EAAAA,IAAAA;MACD;;MAED,OAAA,IAAA;IACD;EAvCmB,CAAP","sourcesContent":["import { isNodePattern } from '@jimp/utils';\n\n/**\n * Creates a circle out of an image.\n * @param {function(Error, Jimp)} options (optional) radius, x, y\n * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n * @returns {Jimp} this for chaining of methods\n */\nexport default () => ({\n  circle(options = {}, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    const radius =\n      options.radius ||\n      (this.bitmap.width > this.bitmap.height\n        ? this.bitmap.height\n        : this.bitmap.width) / 2;\n\n    const center = {\n      x: typeof options.x === 'number' ? options.x : this.bitmap.width / 2,\n      y: typeof options.y === 'number' ? options.y : this.bitmap.height / 2\n    };\n\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(\n      x,\n      y,\n      idx\n    ) {\n      const curR = Math.sqrt(\n        Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2)\n      );\n\n      if (radius - curR <= 0.0) {\n        this.bitmap.data[idx + 3] = 0;\n      } else if (radius - curR < 1.0) {\n        this.bitmap.data[idx + 3] = 255 * (radius - curR);\n      }\n    });\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}