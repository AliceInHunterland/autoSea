{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\n\nexport const registerBackend = (name, backend, priority) => {\n  if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n    const currentBackend = backends[name];\n\n    if (currentBackend === undefined) {\n      backends[name] = {\n        backend,\n        priority\n      };\n    } else if (currentBackend.backend === backend) {\n      return;\n    } else {\n      throw new Error(`backend \"${name}\" is already registered`);\n    }\n\n    if (priority >= 0) {\n      for (let i = 0; i < backendsSortedByPriority.length; i++) {\n        if (backends[backendsSortedByPriority[i]].priority <= priority) {\n          backendsSortedByPriority.splice(i, 0, name);\n          return;\n        }\n      }\n\n      backendsSortedByPriority.push(name);\n    }\n\n    return;\n  }\n\n  throw new TypeError('not a valid backend');\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\n\nexport const resolveBackend = async backendHints => {\n  const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n  const errors = [];\n\n  for (const backendName of backendNames) {\n    const backendInfo = backends[backendName];\n\n    if (backendInfo) {\n      if (backendInfo.initialized) {\n        return backendInfo.backend;\n      } else if (backendInfo.aborted) {\n        continue; // current backend is unavailable; try next\n      }\n\n      const isInitializing = !!backendInfo.initPromise;\n\n      try {\n        if (!isInitializing) {\n          backendInfo.initPromise = backendInfo.backend.init();\n        }\n\n        await backendInfo.initPromise;\n        backendInfo.initialized = true;\n        return backendInfo.backend;\n      } catch (e) {\n        if (!isInitializing) {\n          errors.push({\n            name: backendName,\n            err: e\n          });\n        }\n\n        backendInfo.aborted = true;\n      } finally {\n        delete backendInfo.initPromise;\n      }\n    }\n  }\n\n  throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};","map":{"version":3,"sources":["../../lib/backend-impl.ts"],"names":[],"mappings":"AAAA;AACA;AAaA,MAAM,QAAQ,GAAkC,EAAhD;AACA,MAAM,wBAAwB,GAAa,EAA3C;AAEA;;;;;;;;;AASG;;AACH,OAAO,MAAM,eAAe,GAAG,CAAC,IAAD,EAAe,OAAf,EAAiC,QAAjC,KAA2D;EACxF,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,IAAf,KAAwB,UAAnC,IAAiD,OAAO,OAAO,CAAC,oBAAf,KAAwC,UAA7F,EAAyG;IACvG,MAAM,cAAc,GAAG,QAAQ,CAAC,IAAD,CAA/B;;IACA,IAAI,cAAc,KAAK,SAAvB,EAAkC;MAChC,QAAQ,CAAC,IAAD,CAAR,GAAiB;QAAC,OAAD;QAAU;MAAV,CAAjB;IACD,CAFD,MAEO,IAAI,cAAc,CAAC,OAAf,KAA2B,OAA/B,EAAwC;MAC7C;IACD,CAFM,MAEA;MACL,MAAM,IAAI,KAAJ,CAAU,YAAY,IAAI,yBAA1B,CAAN;IACD;;IAED,IAAI,QAAQ,IAAI,CAAhB,EAAmB;MACjB,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,wBAAwB,CAAC,MAA7C,EAAqD,CAAC,EAAtD,EAA0D;QACxD,IAAI,QAAQ,CAAC,wBAAwB,CAAC,CAAD,CAAzB,CAAR,CAAsC,QAAtC,IAAkD,QAAtD,EAAgE;UAC9D,wBAAwB,CAAC,MAAzB,CAAgC,CAAhC,EAAmC,CAAnC,EAAsC,IAAtC;UACA;QACD;MACF;;MACD,wBAAwB,CAAC,IAAzB,CAA8B,IAA9B;IACD;;IACD;EACD;;EAED,MAAM,IAAI,SAAJ,CAAc,qBAAd,CAAN;AACD,CAxBM;AA0BP;;;;;;;AAOG;;AACH,OAAO,MAAM,cAAc,GAAG,MAAM,YAAN,IAA2D;EACvF,MAAM,YAAY,GAAG,YAAY,CAAC,MAAb,KAAwB,CAAxB,GAA4B,wBAA5B,GAAuD,YAA5E;EACA,MAAM,MAAM,GAAG,EAAf;;EACA,KAAK,MAAM,WAAX,IAA0B,YAA1B,EAAwC;IACtC,MAAM,WAAW,GAAG,QAAQ,CAAC,WAAD,CAA5B;;IACA,IAAI,WAAJ,EAAiB;MACf,IAAI,WAAW,CAAC,WAAhB,EAA6B;QAC3B,OAAO,WAAW,CAAC,OAAnB;MACD,CAFD,MAEO,IAAI,WAAW,CAAC,OAAhB,EAAyB;QAC9B,SAD8B,CACnB;MACZ;;MAED,MAAM,cAAc,GAAG,CAAC,CAAC,WAAW,CAAC,WAArC;;MACA,IAAI;QACF,IAAI,CAAC,cAAL,EAAqB;UACnB,WAAW,CAAC,WAAZ,GAA0B,WAAW,CAAC,OAAZ,CAAoB,IAApB,EAA1B;QACD;;QACD,MAAM,WAAW,CAAC,WAAlB;QACA,WAAW,CAAC,WAAZ,GAA0B,IAA1B;QACA,OAAO,WAAW,CAAC,OAAnB;MACD,CAPD,CAOE,OAAO,CAAP,EAAU;QACV,IAAI,CAAC,cAAL,EAAqB;UACnB,MAAM,CAAC,IAAP,CAAY;YAAC,IAAI,EAAE,WAAP;YAAoB,GAAG,EAAE;UAAzB,CAAZ;QACD;;QACD,WAAW,CAAC,OAAZ,GAAsB,IAAtB;MACD,CAZD,SAYU;QACR,OAAO,WAAW,CAAC,WAAnB;MACD;IACF;EACF;;EAED,MAAM,IAAI,KAAJ,CAAU,oCAAoC,MAAM,CAAC,GAAP,CAAW,CAAC,IAAI,IAAI,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,EAApC,EAAwC,IAAxC,CAA6C,IAA7C,CAAkD,EAAhG,CAAN;AACD,CAhCM","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = {};\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @internal\n */\nexport const registerBackend = (name, backend, priority) => {\n    if (backend && typeof backend.init === 'function' && typeof backend.createSessionHandler === 'function') {\n        const currentBackend = backends[name];\n        if (currentBackend === undefined) {\n            backends[name] = { backend, priority };\n        }\n        else if (currentBackend.backend === backend) {\n            return;\n        }\n        else {\n            throw new Error(`backend \"${name}\" is already registered`);\n        }\n        if (priority >= 0) {\n            for (let i = 0; i < backendsSortedByPriority.length; i++) {\n                if (backends[backendsSortedByPriority[i]].priority <= priority) {\n                    backendsSortedByPriority.splice(i, 0, name);\n                    return;\n                }\n            }\n            backendsSortedByPriority.push(name);\n        }\n        return;\n    }\n    throw new TypeError('not a valid backend');\n};\n/**\n * Resolve backend by specified hints.\n *\n * @param backendHints - a list of execution provider names to lookup. If omitted use registered backends as list.\n * @returns a promise that resolves to the backend.\n *\n * @internal\n */\nexport const resolveBackend = async (backendHints) => {\n    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n    const errors = [];\n    for (const backendName of backendNames) {\n        const backendInfo = backends[backendName];\n        if (backendInfo) {\n            if (backendInfo.initialized) {\n                return backendInfo.backend;\n            }\n            else if (backendInfo.aborted) {\n                continue; // current backend is unavailable; try next\n            }\n            const isInitializing = !!backendInfo.initPromise;\n            try {\n                if (!isInitializing) {\n                    backendInfo.initPromise = backendInfo.backend.init();\n                }\n                await backendInfo.initPromise;\n                backendInfo.initialized = true;\n                return backendInfo.backend;\n            }\n            catch (e) {\n                if (!isInitializing) {\n                    errors.push({ name: backendName, err: e });\n                }\n                backendInfo.aborted = true;\n            }\n            finally {\n                delete backendInfo.initPromise;\n            }\n        }\n    }\n    throw new Error(`no available backend found. ERR: ${errors.map(e => `[${e.name}] ${e.err}`).join(', ')}`);\n};\n//# sourceMappingURL=backend-impl.js.map"]},"metadata":{},"sourceType":"module"}