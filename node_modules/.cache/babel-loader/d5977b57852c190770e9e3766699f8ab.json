{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseBitmap = parseBitmap;\nexports.getBuffer = getBuffer;\nexports.getBufferAsync = getBufferAsync;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _fileType = _interopRequireDefault(require(\"file-type\"));\n\nvar _exifParser = _interopRequireDefault(require(\"exif-parser\"));\n\nvar _utils = require(\"@jimp/utils\");\n\nvar constants = _interopRequireWildcard(require(\"../constants\"));\n\nvar MIME = _interopRequireWildcard(require(\"./mime\"));\n\nvar _promisify = _interopRequireDefault(require(\"./promisify\"));\n\nfunction getMIMEFromBuffer(buffer, path) {\n  var fileTypeFromBuffer = (0, _fileType[\"default\"])(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\n\n\nfunction getExifOrientation(img) {\n  return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;\n}\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\n\n\nfunction getExifOrientationTransformation(img) {\n  var w = img.getWidth();\n  var h = img.getHeight();\n\n  switch (getExifOrientation(img)) {\n    case 1:\n      // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n\n    case 2:\n      // Mirror horizontal\n      return function (x, y) {\n        return [w - x - 1, y];\n      };\n\n    case 3:\n      // Rotate 180\n      return function (x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n\n    case 4:\n      // Mirror vertical\n      return function (x, y) {\n        return [x, h - y - 1];\n      };\n\n    case 5:\n      // Mirror horizontal and rotate 270 CW\n      return function (x, y) {\n        return [y, x];\n      };\n\n    case 6:\n      // Rotate 90 CW\n      return function (x, y) {\n        return [y, h - x - 1];\n      };\n\n    case 7:\n      // Mirror horizontal and rotate 90 CW\n      return function (x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n\n    case 8:\n      // Rotate 270 CW\n      return function (x, y) {\n        return [w - y - 1, x];\n      };\n\n    default:\n      return null;\n  }\n}\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\n\n\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  var _data = img.bitmap.data;\n  var _width = img.bitmap.width;\n  var data = Buffer.alloc(_data.length);\n\n  for (var x = 0; x < width; x++) {\n    for (var y = 0; y < height; y++) {\n      var _transformation = transformation(x, y),\n          _transformation2 = (0, _slicedToArray2[\"default\"])(_transformation, 2),\n          _x = _transformation2[0],\n          _y = _transformation2[1];\n\n      var idx = width * y + x << 2;\n\n      var _idx = _width * _y + _x << 2;\n\n      var pixel = _data.readUInt32BE(_idx);\n\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\n\n\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n  var transformation = getExifOrientationTransformation(img);\n  var swapDimensions = getExifOrientation(img) > 4;\n  var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n  transformBitmap(img, newWidth, newHeight, transformation);\n} // parses a bitmap from the constructor to the JIMP bitmap property\n\n\nfunction parseBitmap(data, path, cb) {\n  var mime = getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    var _mime = this.getMIME();\n\n    if (this.constructor.decoders[_mime]) {\n      this.bitmap = this.constructor.decoders[_mime](data);\n    } else {\n      return _utils.throwError.call(this, 'Unsupported MIME type: ' + _mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = _exifParser[\"default\"].create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;\n}\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\n\n\nfunction getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== 'string') {\n    return _utils.throwError.call(this, 'mime must be a string', cb);\n  }\n\n  if (typeof cb !== 'function') {\n    return _utils.throwError.call(this, 'cb must be a function', cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    var buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n\n  return this;\n}\n\nfunction getBufferAsync(mime) {\n  return (0, _promisify[\"default\"])(getBuffer, this, mime);\n}","map":{"version":3,"sources":["../../src/utils/image-bitmap.js"],"names":["fileTypeFromBuffer","MIME","img","w","h","getExifOrientation","_data","_width","data","Buffer","x","y","_x","_y","transformation","idx","width","_idx","pixel","getExifOrientationTransformation","swapDimensions","newWidth","newHeight","transformBitmap","mime","getMIMEFromBuffer","cb","throwError","EXIFParser","exifRotate","image","constants","compositeBitmapOverBackground","buffer"],"mappings":"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","sourcesContent":["import fileType from 'file-type';\n\nimport EXIFParser from 'exif-parser';\nimport { throwError } from '@jimp/utils';\n\nimport * as constants from '../constants';\nimport * as MIME from './mime';\nimport promisify from './promisify';\n\nfunction getMIMEFromBuffer(buffer, path) {\n  const fileTypeFromBuffer = fileType(buffer);\n\n  if (fileTypeFromBuffer) {\n    // If fileType returns something for buffer, then return the mime given\n    return fileTypeFromBuffer.mime;\n  }\n\n  if (path) {\n    // If a path is supplied, and fileType yields no results, then retry with MIME\n    // Path can be either a file path or a url\n    return MIME.getType(path);\n  }\n\n  return null;\n}\n\n/*\n * Obtains image orientation from EXIF metadata.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {number} a number 1-8 representing EXIF orientation,\n *          in particular 1 if orientation tag is missing\n */\nfunction getExifOrientation(img) {\n  return (img._exif && img._exif.tags && img._exif.tags.Orientation) || 1;\n}\n\n/**\n * Returns a function which translates EXIF-rotated coordinates into\n * non-rotated ones.\n *\n * Transformation reference: http://sylvana.net/jpegcrop/exif_orientation.html.\n *\n * @param img {Jimp} a Jimp image object\n * @returns {function} transformation function for transformBitmap().\n */\nfunction getExifOrientationTransformation(img) {\n  const w = img.getWidth();\n  const h = img.getHeight();\n\n  switch (getExifOrientation(img)) {\n    case 1: // Horizontal (normal)\n      // does not need to be supported here\n      return null;\n\n    case 2: // Mirror horizontal\n      return function(x, y) {\n        return [w - x - 1, y];\n      };\n\n    case 3: // Rotate 180\n      return function(x, y) {\n        return [w - x - 1, h - y - 1];\n      };\n\n    case 4: // Mirror vertical\n      return function(x, y) {\n        return [x, h - y - 1];\n      };\n\n    case 5: // Mirror horizontal and rotate 270 CW\n      return function(x, y) {\n        return [y, x];\n      };\n\n    case 6: // Rotate 90 CW\n      return function(x, y) {\n        return [y, h - x - 1];\n      };\n\n    case 7: // Mirror horizontal and rotate 90 CW\n      return function(x, y) {\n        return [w - y - 1, h - x - 1];\n      };\n\n    case 8: // Rotate 270 CW\n      return function(x, y) {\n        return [w - y - 1, x];\n      };\n\n    default:\n      return null;\n  }\n}\n\n/*\n * Transforms bitmap in place (moves pixels around) according to given\n * transformation function.\n *\n * @param img {Jimp} a Jimp image object, which bitmap is supposed to\n *        be transformed\n * @param width {number} bitmap width after the transformation\n * @param height {number} bitmap height after the transformation\n * @param transformation {function} transformation function which defines pixel\n *        mapping between new and source bitmap. It takes a pair of coordinates\n *        in the target, and returns a respective pair of coordinates in\n *        the source bitmap, i.e. has following form:\n *        `function(new_x, new_y) { return [src_x, src_y] }`.\n */\nfunction transformBitmap(img, width, height, transformation) {\n  // Underscore-prefixed values are related to the source bitmap\n  // Their counterparts with no prefix are related to the target bitmap\n  const _data = img.bitmap.data;\n  const _width = img.bitmap.width;\n\n  const data = Buffer.alloc(_data.length);\n\n  for (let x = 0; x < width; x++) {\n    for (let y = 0; y < height; y++) {\n      const [_x, _y] = transformation(x, y);\n\n      const idx = (width * y + x) << 2;\n      const _idx = (_width * _y + _x) << 2;\n\n      const pixel = _data.readUInt32BE(_idx);\n      data.writeUInt32BE(pixel, idx);\n    }\n  }\n\n  img.bitmap.data = data;\n  img.bitmap.width = width;\n  img.bitmap.height = height;\n}\n\n/*\n * Automagically rotates an image based on its EXIF data (if present).\n * @param img {Jimp} a Jimp image object\n */\nfunction exifRotate(img) {\n  if (getExifOrientation(img) < 2) return;\n\n  const transformation = getExifOrientationTransformation(img);\n  const swapDimensions = getExifOrientation(img) > 4;\n\n  const newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;\n  const newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;\n\n  transformBitmap(img, newWidth, newHeight, transformation);\n}\n\n// parses a bitmap from the constructor to the JIMP bitmap property\nexport function parseBitmap(data, path, cb) {\n  const mime = getMIMEFromBuffer(data, path);\n\n  if (typeof mime !== 'string') {\n    return cb(new Error('Could not find MIME for Buffer <' + path + '>'));\n  }\n\n  this._originalMime = mime.toLowerCase();\n\n  try {\n    const mime = this.getMIME();\n\n    if (this.constructor.decoders[mime]) {\n      this.bitmap = this.constructor.decoders[mime](data);\n    } else {\n      return throwError.call(this, 'Unsupported MIME type: ' + mime, cb);\n    }\n  } catch (error) {\n    return cb.call(this, error, this);\n  }\n\n  try {\n    this._exif = EXIFParser.create(data).parse();\n    exifRotate(this); // EXIF data\n  } catch (error) {\n    /* meh */\n  }\n\n  cb.call(this, null, this);\n\n  return this;\n}\n\nfunction compositeBitmapOverBackground(Jimp, image) {\n  return new Jimp(\n    image.bitmap.width,\n    image.bitmap.height,\n    image._background\n  ).composite(image, 0, 0).bitmap;\n}\n\n/**\n * Converts the image to a buffer\n * @param {string} mime the mime type of the image buffer to be created\n * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument\n * @returns {Jimp} this for chaining of methods\n */\nexport function getBuffer(mime, cb) {\n  if (mime === constants.AUTO) {\n    // allow auto MIME detection\n    mime = this.getMIME();\n  }\n\n  if (typeof mime !== 'string') {\n    return throwError.call(this, 'mime must be a string', cb);\n  }\n\n  if (typeof cb !== 'function') {\n    return throwError.call(this, 'cb must be a function', cb);\n  }\n\n  mime = mime.toLowerCase();\n\n  if (this._rgba && this.constructor.hasAlpha[mime]) {\n    this.bitmap.data = Buffer.from(this.bitmap.data);\n  } else {\n    // when format doesn't support alpha\n    // composite onto a new image so that the background shows through alpha channels\n    this.bitmap.data = compositeBitmapOverBackground(\n      this.constructor,\n      this\n    ).data;\n  }\n\n  if (this.constructor.encoders[mime]) {\n    const buffer = this.constructor.encoders[mime](this);\n    cb.call(this, null, buffer);\n  } else {\n    cb.call(this, 'Unsupported MIME type: ' + mime);\n  }\n\n  return this;\n}\n\nexport function getBufferAsync(mime) {\n  return promisify(getBuffer, this, mime);\n}\n"]},"metadata":{},"sourceType":"script"}