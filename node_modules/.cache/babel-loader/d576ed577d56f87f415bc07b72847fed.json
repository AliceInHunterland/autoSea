{"ast":null,"code":"const {\n  defaultArgs,\n  baseOptions\n} = require('./config');\n\nconst {\n  setLogging,\n  setCustomLogger,\n  log\n} = require('./utils/log');\n\nconst parseProgress = require('./utils/parseProgress');\n\nconst parseArgs = require('./utils/parseArgs');\n\nconst {\n  defaultOptions,\n  getCreateFFmpegCore\n} = require('./node');\n\nconst {\n  version\n} = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = function () {\n  let _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = { ...baseOptions,\n    ...defaultOptions,\n    ..._options\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n\n  const detectCompletion = message => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n\n  const parseMessage = _ref => {\n    let {\n      type,\n      message\n    } = _ref;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: message => parseMessage({\n          type: 'fferr',\n          message\n        }),\n        print: message => parseMessage({\n          type: 'ffout',\n          message\n        }),\n\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined') {\n            if (typeof wasmPath !== 'undefined' && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n\n            if (typeof workerPath !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n\n          return prefix + path;\n        }\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  const isLoaded = () => Core !== null;\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  const run = function () {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(resolve => {\n        const args = [...defaultArgs, ..._args].filter(s => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  const FS = function (method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    log('info', `run FS.${method} ${args.map(arg => typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`).join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n\n\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  const setProgress = _progress => {\n    progress = _progress;\n  };\n\n  const setLogger = _logger => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n  log('info', `use ffmpeg.wasm v${version}`);\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS\n  };\n};","map":{"version":3,"names":["defaultArgs","baseOptions","require","setLogging","setCustomLogger","log","parseProgress","parseArgs","defaultOptions","getCreateFFmpegCore","version","NO_LOAD","Error","module","exports","_options","logging","logger","progress","optProgress","options","Core","ffmpeg","runResolve","running","detectCompletion","message","parseMessage","type","load","createFFmpegCore","corePath","workerPath","wasmPath","mainScriptUrlOrBlob","printErr","print","locateFile","path","prefix","window","endsWith","cwrap","isLoaded","run","_args","join","Promise","resolve","args","filter","s","length","FS","method","map","arg","ret","e","exit","setProgress","_progress","setLogger","_logger"],"sources":["/Users/ekaterinapavlova/PycharmProjects/onix/autoSea/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      /*\n       * In node environment, all paths are undefined as there\n       * is no need to set them.\n       */\n      const {\n        createFFmpegCore,\n        corePath,\n        workerPath,\n        wasmPath,\n      } = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        /*\n         * Assign mainScriptUrlOrBlob fixes chrome extension web worker issue\n         * as there is no document.currentScript in the context of content_scripts\n         */\n        mainScriptUrlOrBlob: corePath,\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        /*\n         * locateFile overrides paths of files that is loaded by main script (ffmpeg-core.js).\n         * It is critical for browser environment and we override both wasm and worker paths\n         * as we are using blob URL instead of original URL to avoid cross origin issues.\n         */\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined') {\n            if (typeof wasmPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.wasm')) {\n              return wasmPath;\n            }\n            if (typeof workerPath !== 'undefined'\n              && path.endsWith('ffmpeg-core.worker.js')) {\n              return workerPath;\n            }\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  /**\n   * forcibly terminate the ffmpeg program.\n   */\n  const exit = () => {\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      running = false;\n      Core.exit(1);\n      Core = null;\n      ffmpeg = null;\n      runResolve = null;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    exit,\n    FS,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}